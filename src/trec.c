/*********************************************************************

trec.c: tile a rectangle with a given polyomino.

Copyright (c) Karl Dahlke, 2020.
http://www.eklhad.net

The author reserves all rights regarding the application of these patterns
to commercial products such as recreational puzzles, T-shirts, posters, etc.

The polyomino, and other options for the running program,
are specified in the config file.
Thus the config file is the only argument.
You can pass a bitmap as an option to the program,
but that is only for debugging/tuning.

Here is an overview of the algorithm.
Consider a 5x2 piece such as f860.
This is 5 squares in a row and then two more above the second and third squares.
If there is a rectangular tiling based on this piece,
break it at row 50 (i.e. between rows 50 and 51).
Course we don't want to cut any pieces in half, so there are some rules.
If a piece extends farther down into the lower half than the upper, include it
in the lower half.  That settles things if our gun is oriented vertically.
If the piees exactly straddles the border, and the heavier end, as measured by
the number of squares, or perhaps its center of mass, hangs down,
include the piece in the lower section.
Now the break is implemented, and gives the same pattern whether
approached from below or above.

Sadly, we must deal with some ambiguity.
Consider the pair of hexominoes f08080 and c06030.
The second piece is stairs, and it can be oriented with 3 squares above
the break line and 3 squares below, with perfect rotational symmetry.
Any rule we might apply puts the piece on both sides,
or excludes the piece altogether.
The C hexomino c08080c0 has the same problem through vertical reflection.
Yet I want to process pairs of hexominoes that contain these pieces. What to do?
Generate two nodes instead of one:
the node with the ambiguous pieces included, when the variable
ambinclude is true, and a node without these pieces, when ambinclude is false.
When the bottom node with these pieces, and the top node without,
are both in our database, they will match, and a tiling is produced.
For wide boards, a break often includes at least one ambiguous piece,
So we are generating twice as manyh nodes as we need, but oh well. I print
a warning if a piece is ambiguous, but not through reflection or rotation.

The break pattern is stored in a node.
The depth of the node is the number of complete rows before the break
is evident.  In our case the depth may be 50, 49, or 48.
Not 47, since a piece that extends 3 rows down would be included
in the lower section.  In general the depth could be flush with the breakline,
or (at worst) pieceLength/2 rows below.
In rare cases the depth could be above the breakLine.
If the pieceLength is at least 4, and all pieces hang below,
they could extend up across the breakLine and completely cover the next row,
while some extend into the row after that.
Imagine each f860 piece breaking at line 50 is a gun pointing down,
all oriented vertically, barrels extending 3 rows down to stand atop row 47,
then the back of the gun on rows 51 and 52.
This happens all the way across, so depth is 51, while breakline is 50.
As I say, this is rare, but we must consider it.

The pattern gap is the distance between the depth and the highest piece.
Since the depth is no more than pieceLength/2 from the breakLine,
the gap is no more than pieceLength/2*2,
which basically rounds pieceLength down to the nearest even number.

Each column of a pattern is stored in a bitmap, designating the squares
that are occupied, as the pattern is viewed from one side or the other.
We only consider pieces that span 9 squares, so the gap is
no more than 8, and the bits can always be stored in a byte.
Isn't that convenient?

We first generate the nodes at depth 1, then 2, then 3, and so on,
always looking for a node that exactly complements a previously generated node.
This assumes we remember each node we generate,
which is why you really need lots of memory,
or virtual memory, to run this program.

Imagine a long array of nodes, initially seeded with the node of all zeros,
the floor of the rectangle.
New nodes are appended to this array as they are generated.
Set curDepth = 0 to start.
*********************************************************************/

static int nsq; // number of squares in the polyomino
static int curWidth; // current width of rectangle being tiled
static int curWidth1; // curWidth + 1
static int curNodeWidth;
static int curDepth; // depth of nodes being expanded

/*********************************************************************
Repeat the following procedure for higher and higher values of curDepth.
By assumption, the array contains nodes at depth curDepth.
These were generated by expanding nodes at earlier depths.
Start at the beginning of the array and expand each curDepth node in turn.
This expansion may add more nodes to the end of the array,
and some of these nodes may be at the same depth, curDepth,
but we'll run into them as we move through the array,
and when we're done, all nodes at depth curDepth will be expanded.
You can't generate a node at a lower depth, since everything up to curDepth is filled in.

What does it mean to expand a node?
Since we only remember the pattern, we don't know where
the breakline was that lead to this pattern, nor can we reconstruct this
information, since we don't know the orientations of the pieces that built 
the pattern when the break was made.
But we know the breakLine that made this node was no more
than pieceLength/2 above curDepth.
Any higher and the depth of the node would be greater.
We're interested in generating a new node from this one.
We can accomplish this as follows.

Increment the maximal breakLine,
tile all squares up to the new breakLine,
and partition the pieces according to a new breakLine,
to produce a new pattern at a possibly higher depth.
We want to generate all possible nodes,
so we run an exhaustive search, a push and pop algorithm.
Start with breakLine 1 more than curDepth + pieceLength/2. Call this b.
Assume n1 is the current node and n2 is the node we want to discover,
at the same or higher depth.
Fill in the pieces of n2 that ride on top of curDepth first.
With breakline b, all these pieces are brought in.
More perhaps but at least these.
So we find n2, or an intermediate node n3 at a higher depth
which will be evaluated later, to produce n2.
It's enough to tile up to b and no farther, and see what nodes we find.

We can only evaluate the breakline based on the new pieces added.
If the breakline is k, then lowering it to k-1 gets rid of at least one piece.
Add piece p, and evaluate where it breaks, when it first flips to the other side.
Let l be the highest level where this doesn't happen.
l is always larger than curDepth.
If l is less then k then set k = l.
Put k back when you remove p.
When the board is tiled up to or beyond k, we have a node, and a breakline.
If it's complement is on the list, we have found a solution.
If it is not on the list, then add it to the end.

Here's how a new node can have the same depth.
The first few pieces added are verticle, whence l = curDepth + 3.
any lower and those pieces would be excluded from n2.
Piece p is horizontal.
If it is face up then l = curDepth + 1.
If it is face down then l = curDepth + 2.
Pull k down to l when adding p.
If we can tile up to k, then p is part of the new node,
but the vertical guns are not.
There are still empty squares at curDepth, and the depth of the new node is curDepth.
This might be n3, between n1 and n2, but we'll expand n3,
and add more pieces, and we'll get to n2 eventually.

Assume a solution. Slide the breakline up from the floor to the ceiling.
This generates a sequence of nodes at ever increasing depths.
By induction, each is generated from the node before.
We'll find all the nodes all the way up to the top,
or, the node and its complement at approximately the halfway mark.

There may be hundreds of millions of nodes, and it's a shame
to store and expand and crosscheck a node that doesn't go anywhere.
The lookahead parameter asks the algorithm to tile beyond the breakline,
just to make sure it is possible.
This is 1 through 4.
Yes, I always tile at least one rwo beyond the breakline;
that seems to be more efficient in every case.
High lookahead spends more time verifying each node, but stores fewer nodes,
since many of them don't go anywhere.
This is set by the config file, but can be changed at run time.
The interactive interface will be described later.

Here is the push and pop.

advance:
Push the stack, ready to place another piece.
Consider all the empty squares in the first row
that have pieces filled in to the west.
If there are no empty squares, consider the next row,
on up through breakLine rows.
If there are no empty squares in the first breakLine rows, goto complete.
Assuming there are empty squares to populate,
select the best empty square, probably the one with the fewest
viable orientations.

next:
Try the next orientation of the polyomino in this location.
If there are no valid orientations remaining, goto backup.
Place the piece on the board.
Find the lowest breakline that will include this piece.
If this new breakline is less than the previous value of breakLine, downgrade it.
goto advance.

backup:
Pop the stack - we are now looking at the previous piece placed on the board.
If the stack is empty, return, this node has been expanded.
Take the piece off the board.
Resurrect the old value of breakLine.
goto next.

complete:
Break the board at breakLine.
Compute the depth of this new node; call it newDepth.
If(we've seen this node before) {
if(newDepth is less than the preestablished depth for this node) {
Mark the node with this lower depth.
If the lower depth is curDepth,
move the node to the end of the array,
so we can process it in this pass.
}
goto backup.
}
Place the new node on the end of the array.
Compute the complement of the node
and see if we have generated it before.
If we have {
We have tiled a rectangle!
Compute the size of this rectangle.
If it's bettern than our best so far,
crank out the new tiled rectangle and remember it as our best.
The solution is an ascii file of letters, but you can turn it into an image
using the letterart program.
}
goto backup.

Finally the depth limit is reached and the program stops.
Sounds easy, doesn't it?

If you're serious about maintaining, enhancing, debugging, this program,
you need to build a screen interface that shows the program testing pieces
in certain positions, counting viable orientations, selecting squares,
placing pieces, unplacing pieces, moving to the next orientation,
building nodes based on the breakline, and so on.
Just letting it run is almost like a neural network;
you really don't know what is going on inside.

Now let's talk about the config file.
This file is line oriented.
Everything from # to end-of-line is ignored (comment).
Each of the first eight lines must be present, and syntactically correct.

The first line gives the polyomino, using the hex format described in
http://www.eklhad.net/polyomino/even.html
We also allow a + to set the ninth bit.
Thus ff+fcfc is a long version of Oklahoma,
with a row of 9 squares and two rows of 6 squares.
Use braces for a longer row, as in ffff{e0} for a row of 11,
although shapes longer than 9 cannot currrently be analyzed.

You can specify a set of polyominoes on the first line, using _ as delimiter.
Thus 70d0_e070 describes a pair of hexominoes
that have order 130, as a set,
even though neither tiles a rectangle on its own.
At present, all the shapes in a set must have the same number of squares.

You can add a ~ modifier to the end of a shape.
This prohibits certain orientations when the shape is on the floor.
We rotate things to prohibit the corresponding orientations
against the left and right walls.
~n prohibits the normal orientation, as the piece is written.
~u prohibits the upside down orientation.
~l prohibits the left orientation, counterclocwise turn.
~r prohibits the right orientation, clocwise turn.
Thus you might write the earlier set as
70d0~u_80f020~nu
Then again, you might not, because the extra code needed
to make these checks sometimes makes the program run slower.
Sometimes, but not always.
This feature isn't too helpful when an orientation would be ruled out anyways
by the next piece.
However, there are times when the orientation seems fine,
even after several more pieces have been placed.
In the set f08080~u_c06030~nulr
You'd think stairs could be placed on the floor.
But you always have to slide more stairs beneath those stairs,
and that continues forever,
so we disallow any stairs on the floor, in any orientation.
This makes a big difference.
Instead of wasting time on all those patterns with stairs
propagating up the left and right walls,
the program soon finds the order 318 solution, 36x53.

The second line sets the initial width.
We search for a rectangle with this width, then increase the width,
until we find a solution.

This line can also be used to resume the program after a controlled shutdown.
If you were analyzing rectangles of width 40,
and the last thing you saw was @27,
put  40@27  in the second line of the config file.
This resumes the program at width 40, depth 27,
using the files that were present when the program stopped earlier.
This should work if the program stopped because of SIGTERM, SIGQUIT,
or q at the interactive menu.

The letter a means allcheck, so 54a will look for solutions
even if the rectangle is wider than it is tall.
Perhaps you ruled out rectangles up to width 48.
You are dealing with hexominoes, so a width divisible by 6 is better.
Jump ahead to 54, but you still want to check for 54x49.
I don't normally check for that, assuming we are incrementing the width
as we go, but you can override this with the letter a here,
or with -2 on the command line.

The third line is a bound on the order.
Don't look for larger solutions than this.

If this is zero, the program doesn't look for rectangles at all.
Instead, it tiles a strip of the given width up the left wall,
without worrying about the stuff hanging off to the right.
I call this a ragged strip, as the right edge is ragged and ill-defined.
If you can't tile such a strip, you certainly can't tile a rectangle.
Some shapes are ruled out by this technique.
For instance, fcf8c0 tiles a quadrant,
but will not tile a finite ragged strip of width 12.

The fourth line determines the number of nodes,
in millions of nodes, that will be maintained in cache.
You can specify up to 400 million nodes,
but that chews up 2 gig of ram in a linear array.
Basically, multiply the number by 4.5 meg for ram consumed.
If the cache overflows, this program stops, gracefully.
You want to restart it with a higher cache, as per your computer's resources.
It's probably best to start with the highest cache you expect to need,
because the resume process is not efficient.

The fifth line sets the number of worker threads.
Use 0 to do all calculations in the foreground.
1 worker thread won't bring any benefit, but could be used for testing.
If you have a quad core CPU, 4 threads will use all 4 processors.
But if you want your computer to respond to your interactive commands
in a timely manner, you might want to set 3 worker threads,
and leave a processor for yourself.
Threads do not help very much; we should probably look for improvements elsewhere.

The sixth line tells the program how many rows to look ahead.
Normally the program tiles up to the breakline, and then calls it a node,
but there's no sense wasting cache and disk space on a dead-end node.
So sometimes we want to tile beyond the breakline,
to make sure the node is valid.
Then again, it takes extra time to tile more rows on top of each node.
You'll have to trade space against time.
Set lookahead high to conserve nodes on disk and in cache.
Set lookahead = 1 for faster performance on small rectangles.
I find that lookahead = 2 works well,
and that's what I usually use,
unless I'm trying to conserve nodes for very large rectangles.
Multiple threads must queue up and wait for disk and cache access,
so creating fewer nodes is better, i.e. lookahead = 3 or 4.
Lookahead values range from 1 to 4.

The seventh line is a factor on the order.
Set this to 2 to force an even order.
We often know the order is divisible by something.

The eighth line is a factor on the dimension.
Boundary conditions often force both diminsions to be divisible by something.

A line with a single hyphen on it marks the end of data
and the beginning of comments about this shape.
Perhaps a proof as to why the order or the dimension are divisible
by certain numbers, or the best solution so far,
or the dimensions we have already explored.

Sample config file:

e0f080~u  # a row of 3, then a row of 4, then a single square
30  # start at 30 rows
210  # don't look for rectangles with more than 210 pieces
2  # 2 million nodes in cache
0 # no worker threads
2  # look ahead 2 rows
2  # checkerboard argument implies an even order
2  # pairs of pieces on the floor consume 4|6 squares
-
~u actually slows things down a little in this case.

The folowing comments attempt to justify my stop-search criterion.
This is not easy or obvious.

Let the piece have height h and width w, with h >= w,
and assume we are looking for a solution with n rows.
I can break the rectangle at any point.
That is, I choose any breakline b.
this produces a bottom and top "half" of the rectangle.
I'll call them left and right halves.
Each piece along the breakline hangs left or right,
according to its center of mass, and that determines the split.
The number of complete rows in the left half is l,
and the number of complete rows in the right half is r.
Note that l+r+h > n, and l+r < n.

If l is at least b, all the pieces that straddle the breakline hang left.
How else could all the rows, up to the breakline, be complete?
In fact l could exceed b, as described earlier.
Of course such a node was generated by some other node
with depth less than the breakline.

Numbers are a bit easier to understand than variables,
so suppose we are in the midst of expanding, or about to expand,
the nodes at depth 26.
All nodes at depth <= 25 have been expanded, and they and their
expansions crossmatched.
All nodes at depth 26 have been generated
and crossmatched, except those that are produced by expanding
some other node at depth 26.
This can only happen if the breakline is at least 26+(w+1)/2.
That brings in a piece on its side to add to the node, while other squares could remain empty.
Lower breaklines may indeed produce nodes at depth 26, or higher,
but they've been generated by expanding a node at an earlier depth,
hence they're in our database.

It's important that n1 contained in n2 contained in n3, all at depth 26,
that our algorithm produces n3 from n1, without having to generate it from n2,
although it will generate it from n2 again, but it originally comes from n1.
All nodes at depth 26 come from the existing nodes at depth 26,
withou having to consider additional nodes at depth 26 as seeds.

Consider solutions with n = 52 + w - 1 rows.
Set the breakline b at n/2 = 26 + (w-1)/2.
If l < 26, we've already got the node in the database.
If l >= 26,
the breakline is strictly less than 26 + (w+1)/2,
so that node has been generated. It is in our array.
Take the case where n is even, hence w is odd.
When viewed from the right edge, the breakLine has the same bound,
hence we can make the same conclusions about r.
We've seen both nodes before,
so this solution has already been discovered.
We can stop at depth 26 for 52+w-1.

If we want a solution with exactly 52+w rows, w still odd,
The breakline from the left is the same,
and the breakLine from the right is 26+(w+1)/2.
If the right pattern hasn't been seen yet,
it comes from a node at depth 26, adding a few pieces oriented parallel with the breakLine.
It won't come from a node at depth 27.
We need to expand the nodes at depth 26,
and crossmatch the results, but we don't need to store the results.
A solution of 52+w always matches a newly generated node with a preexisting node.

w odd {
bestRow = 2*depth+w-1 means stop.
bestRow = 2*depth+w means generate and search but don't store.
}

Now let w be even, whence n = 52+w-1 is odd.
Back up to n-1, which is even.
Breakline is 26+w/2 - 1 from either side.
All solutions up to order n-1 have been discovered, using the reasoning above.
Finding none, we continue.
Returning to n, set the breakLine at (n-1)/2,
whence the left node has been generated.
If we haven't found the solution, r is at least 26.
Now r could be generated from a node at depth 26, not 27,
so indeed we must expand nodes at depth 26,
but we don't have to store the results.

w even {
bestRow = 2*depth+w-2 means stop.
bestRow = 2*depth+w-1 means generate and search but don't store.
}

If w is odd, set stopgap = w.
If 2*curDepth+stopgap exceeds bestRow, we can stop,
and if it equals bestRow, we can generate nodes without storing them.
When w is even, set stopgap = w - 1.
If bestRow is belo 2*curDepth + stopgap, we can stop,
and equality means we can generate nodes without storing them.
*********************************************************************/

static int bestOrder; // what is the largest rectangle we are interested in?
static int ordFactor; // order must be a multiple of this
static int dimFactor; // each dimension must be a multiple of this
/* rows in the biggest rectangle circumscribed by the above criteria */
static int bestRow, leastRow;
static int stopgap, forgetgap;

/*********************************************************************
There's another criterion for generate-but-don't-store.
If a generated node x, at a certainh depth, + its gap, + curDepth,
exceeds bestRow,
then the complementary node, if it exists, is below curDepth,
and has already been generated.
So we don't need to store it.
*********************************************************************/

#define stopsearch (2*curDepth + stopgap > bestRow)
#define stopstore(x) (2*curDepth + stopgap == bestRow || curDepth + x.depth + x.gap > bestRow)

/*********************************************************************
Here is an interesting corrilary.
If we are still expanding nodes at 26,
we must be looking for solutions of 52+stopgap or higher.
Earlier solutions would have been found.
Note that stopgap is always odd.
Set the breakline at n/2, at least 26 + stopgap/2.
Remember that l and r are no more than h/2 from the breakline.
Thus we can "forget" any nodes below 26 + stopgap/2 - h/2.
This saves space in the cache, and we won't miss a tiling.
However, we may reintroduce a node at a higher depth
that appeared at an earlier depth,
simply because we didn't find it.
This wastes disk space and cpu cycles,
as we will eventually re-analyze that node,
but it does keep the cache small - entirely in memory -
and that might be worth it.
*********************************************************************/

static void setBestRow(void)
{
int denom = nsq * ordFactor;
bestRow = bestOrder*nsq/curWidth;
do {
if(bestRow%dimFactor) continue;
if(((long)bestRow*curWidth) % denom) continue;
break;
} while(--bestRow);
// We have already covered rows below 2*curDepth + stopgap.
leastRow = 2*curDepth + stopgap;
// We already checked skinnier rectangles.
if(curWidth > leastRow) leastRow = curWidth;
do {
if(leastRow%dimFactor) continue;
if(((long)leastRow*curWidth) % denom) continue;
break;
} while(++leastRow);
} /* setBestRow */

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/stat.h>
#include <pthread.h>

#ifndef O_BINARY
#define O_BINARY 0
#endif

/*********************************************************************
This program considers polyominoes that fit into a 16x16 grid.
This fact is hardcoded in several ways.
In particular, the bitmap image of a piece is stored
in shorts, one short per row.
Also, each bitmap has no more than 16 shorts.
In reality the diameter is limited to 9,
because the patterns that are stored in each node
are represented by byte arrays.
A piece of diameter 9 can only extend 8 up from its anchoring square,
so we can get away with bytes.
If we ever want to analyze larger shapes,
a lot of code will have to change!
*********************************************************************/


#define REPDIAMETER 16 // represent pieces this large
#define NSQ 80 // number of squares in largest polyomino
#define SETSIZE 10 // number of pieces in the set
#define NUMTHREADS 64 // max number of worker threads
#define BOARDWIDTH 256

typedef unsigned char uchar;
typedef signed char schar;
typedef ushort shapebits;
typedef uchar bool;
#define true 1
#define false 0

// short highbit macros
#define HIGHBIT 0x8000
#define isHighbit(word) ((short)(word) < 0)
#define isNotHighbit(word) ((short)(word) >= 0)

// Rotate and reflect a polyominoe in position.
static void clockwise(shapebits *base)
{
int i, j;
int min_x = REPDIAMETER-1, min_y = REPDIAMETER-1;
bool board[REPDIAMETER][REPDIAMETER];

memset(board, false, sizeof(board));

for(i=0; i<REPDIAMETER; ++i) {
shapebits x = base[i];
for(j=0; j<REPDIAMETER; ++j, x<<=1) {
if(isNotHighbit(x)) continue;
if(REPDIAMETER-1-j < min_y) min_y = REPDIAMETER-1-j;
if(i < min_x) min_x = i;
board[REPDIAMETER-1-j][i] = true;
}
}

// Translate back to the lower left corner,
// and repack into the bitmap.
for(i=0; i<=REPDIAMETER-1-min_y; ++i) {
shapebits x = 0;
for(j=0; j<=REPDIAMETER-1-min_x; ++j) {
x <<= 1;
x |= board[i+min_y][j+min_x];
}
base[i] = x << min_x;
}

// zero fill the rest of the bitmap
for(; i<REPDIAMETER; ++i) base[i] = 0;
} /* clockwise */

static void vertReflect(shapebits *base)
{
int i, j;

// find the height of the piece
for(i=0; i<REPDIAMETER; ++i)
if(!base[i]) break;

--i;
for(j=0; j+j<i; ++j) {
shapebits swap = base[j];
base[j] = base[i-j];
base[i-j] = swap;
}
} /*vertReflect */

/* debugging modes for this program */
#define PERFORMCHECK 0x1
#define ORIENTCHECK 0x2
#define NODECHECK 0x4
#define SOLVECHECK 0x8
#define LOOKALLCHECK 0x10
#define ALLCACHE 0x20
#define SHOWTHREAD 0x40
#define CCP 0x80

static int checkBits = 0;

/*********************************************************************
Bailout() prints an error message and aborts.
Follow-on wrappers invoke system calls that *should* work,
and if they don't, we call bailout().
*********************************************************************/

static const char *config;
static const char *piecename;

static void bailout(const char *msg, int arg)
{
if(config) fprintf(stderr, "%s: ", config);
fprintf(stderr, msg, arg);
fprintf(stderr, "\n");
exit(1);
} /* bailout */

static void *emalloc(unsigned int n)
{
void *s = malloc(n);
if(!s) bailout("failure to allocate %d bytes", n);
return s;
} /* emalloc */

static void *erealloc(void *p, unsigned int n)
{
void *s = realloc(p, n);
if(!s) bailout("failure to reallocate %d bytes", n);
return s;
} /* erealloc */

static void eread(int fd, void *buf, unsigned n)
{
if((unsigned)read(fd, buf, n) != n)
bailout("disk read error, errno %d", errno);
} /* eread */

static void ewrite(int fd, const void *buf, unsigned n)
{
const char *s = buf;
int rc;
char hold[24];
top:
rc = write(fd, s, n);
if(rc == (signed)n) return; // good write
// Disk failure, disk is probably full,
// you could save the situation by clearing space.
if(rc > 0) n -= rc, s += rc;
printf("\nDisk failure, errno %d.\n\
If I stop now, all your work at this depth could be lost.\n\
See if you can fix the problem, then hit return, and I will try again.\n\
Or type x and I will exit, and it's game over.\n", errno);
// Don't worry about other threads, all disk access is inside a mutex,
// so the other threads will queue up behind this one, and not write,
// and wait for you to hit return.
if(!fgets(hold, sizeof(hold), stdin) ||
hold[0] == 'x') exit(2);
// Is the file offset still at the end of the file? Sure hope so.
// lseek(fd, 0, SEEK_END);
goto top;
} /* ewrite */

static void elseek(int fd, long offset)
{
if(lseek(fd, offset, SEEK_SET) < 0)
bailout("disk seek error, errno %d", errno);
} /* elseek */

/* for debugging */
static void showPattern(const shapebits *p)
{
int j;
for(j=0; j<curWidth; ++j) {
printf("%x", p[j]);
if(j < curWidth-1) printf(".");
}
} /* showPattern */

/* for debugging */
static void showSmallPattern(const uchar *p)
{
int j;
for(j=0; j<curWidth; ++j)
printf("%x", p[j]);
} /* showSmallPattern */

/*********************************************************************
In order to tile a rectangle with a given polyominoe,
we "compile" said polyominoe for efficiency.
This entails finding all the unique orientations of the piece (up to 8),
and writing down a bitmap for each one.
*********************************************************************/

struct ORIENT { // describe an orientation
short x, y; // offset of bottom left square
uchar h, w; // height and width
short breakLine; // the row with more than half the piece below it
bool ambig; // ambiguous indicator
uchar key;
uchar pno; // piece number in the set
// orientation number as per a convention that will be described later
uchar ono;
uchar rotsym;
uchar maxUnder;
short filler;
shapebits pattern[REPDIAMETER];
shapebits under[REPDIAMETER];
};

#ifdef MANYORIENTS
#define O_MAX 96
#define clearOrientBits(olist) (olist[0] = olist[1] = olist[2] = 0)
#define copyOrientBits(l1, l2) (l1[0] = l2[0], l1[1] = l2[1], l1[2] = l2[2])
#define testOrientBit(o, bit) (o[(bit)>>5] & (1<<((bit)&0x1f)))
#define setOrientBit(o, bit) (o[(bit)>>5] |= (1<<((bit)&0x1f)))
#else
#define O_MAX 32
#define clearOrientBits(olist) (*olist = 0)
#define copyOrientBits(l1, l2) (*l1 = *l2)
#define testOrientBit(o, bit)((*o)&(1<<(bit)))
#define setOrientBit(o, bit)((*o)|=(1<<(bit)))
#endif

/*********************************************************************
Each piece is placed at curDepth, against a square that is occupied,
or the left wall or the right wall.
Orientations that make sense against a left square are stored in o_leftlist.
Orientations that make sense against a right square are stored in o_rightlist.
If we already filled the squares left and right, then we only consider
orientations that poke a thin tab into this slot.
These are in o_midlist, in the middle.
Our f860 gun cannot lie down in this gap; the 4 horizontal
orientations would not be on o_midlist.
If the squares left and above are filled, we want o_l1list.
If the squares right and above are filled, we want o_r1list.
The horizontal guns poke into these gaps and are on o_l1list and o_r1list.
If Two squares on the left are filled, a wall of height 2, we want o_l2list.
If three squares on the left are filled, a wall of height 3, we want o_l3list.

The gun pointing down and facing left actually appears twice on o_leftlist (and o_rightlist).
Once anchored to the floor, x=1 and y=0, the barrel fitting into a notch,
and again with x=0 and y=2, another lower left corner that could fill a notch,
as long as there is room for the barrel to hang below.
This is not a notch at curDepth.
The breakline in the first is 2, and in the second is 0.
So the breakline is relative to the notch where we might place this piece.
At breakline the piece is included, at a lower breakline it is not.
thus there could be more than 8 orientations.
The simple octomino f0e040 has 14.
*********************************************************************/

static struct ORIENT o_leftlist[O_MAX];
static struct ORIENT o_rightlist[O_MAX];
static struct ORIENT o_midlist[O_MAX];
static struct ORIENT o_l1list[O_MAX];
static struct ORIENT o_r1list[O_MAX];
static struct ORIENT o_l2list[O_MAX];
static struct ORIENT o_r2list[O_MAX];
static struct ORIENT o_l3list[O_MAX];
static struct ORIENT o_r3list[O_MAX];
static struct ORIENT o_mid2list[O_MAX];
static const struct ORIENT *o_whichlist[] = {
o_leftlist, o_rightlist, o_midlist,
o_l1list, o_r1list,
o_l2list, o_r2list,
o_l3list, o_r3list,
o_mid2list,
};
static int o_sizes[10];
static int o_max; /* number of orientations */
static int setSize; // for sets of polyominoes
// largest hight and smallest width across all pieces in the set
static int setMinDimension, setMaxDimension;
// height of the current piece being compiled
static int pieceLocalMax;
// the minimum of the heights of the pieces in the set
static int pieceMinMax;
static bool cbflag; // checkerboard flag

static shapebits toHex(char c)
{
c = tolower(c);
if(c >= 'a') c -= ('a'-'9'-1);
return c-'0';
} /* toHex */

static const uchar nibbleCount[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};
static const shapebits revNibble[] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};
static shapebits reverseShort(shapebits v)
{
return revNibble[v>>12] |
(revNibble[(v>>8)&0xf]<<4) |
(revNibble[(v>>4)&0xf]<<8) |
(revNibble[v&0xf]<<12);
} /* reverseShort */

static uchar reverseByte(uchar v)
{
return revNibble[v>>4] |
(revNibble[v&0xf]<<4);
} /* reverseByte */

/*********************************************************************
which orientations are ok on the bottom, left wall, and right wall?
There are 8 orientations.
If a piece can't be upside down on the floor, then neither can its reflection.
If a piece can't lie as is on the floor, then its counterclockwise turn can't be
against the right wall, and its clockwise turn can't be against the left wall.
Each of the four letters, n u r l, rules out two orientations on the floor,
left wall, and right wall.
8 bits in a byte, one per orientation.
1 = normal, lying on the floor, 0x10 is its reflection.
Turn the piece left, counterclockwise, this is 2,
and its reflection, when so turned, is 0x20.
Turn the piece right, clockwise, this is 8 and its reflection 0x80.
Upside down is 4, and reflect that for 0x40.
We can specify forbidden orientations for each piece in the set.
*********************************************************************/
static uchar bo_ok[SETSIZE], lo_ok[SETSIZE], ro_ok[SETSIZE];
static uchar rotsym[SETSIZE]; // rotational symmetry
static bool wallRestrict; // there are restrictions by a wall

/*********************************************************************
Orientations are placed in o_leftlist,
and each is reflected and put in o_rightlist.
We will see if they can be put on the other lists later.
Some can, some can't.
Aside from moving bits around, we have to change the orientation indicator,
using the convention that was established above.
0 is flat on the floor as written in the config file,
and 4 is the horizontal reflection, so 0 becomes 4 and 4 becomes 0.
1 is a counterclockwise turn, so its reflection is accomplished by reflecting
the original piece and turning it clockwise, which is 7.
You can verify the other cases.
*********************************************************************/
static const uchar hrefOrient[8] = {4,7,6,5,0,3,2,1};

static void compileRotations(shapebits *new, int bx, int by);
static void compilePiece(const shapebits *new, int bx, int by, int ono);
static void reflectCompiledPiece(void);

// Convert a hex-format representation of a polyomino into its bitmap,
// and derive all its rotations.
static void stringPiece(const char *hexrep)
{
shapebits mask;
const char *s;
int i, j;
shapebits piece[REPDIAMETER];
bool cbf;
int bx, by; // bounding rectanghle x and y
char c;
uchar bo, lo, ro;
int nsqFirst = -1;

if(!(checkBits&CCP))
printf(";%s\n", hexrep);

s = hexrep;
o_max = 0;
setMaxDimension = 0, setMinDimension = pieceMinMax = NSQ;
setSize = 0;
cbflag = true;

while(*s) {
if(setSize >= SETSIZE) bailout("too many pieces in the set, limit %d", SETSIZE);
pieceLocalMax = 0;
memset(piece, 0, REPDIAMETER*sizeof(shapebits));
nsq = 0;
i = 0;
mask = 0;

while((c = *s) != 0 && !strchr("_~", c)) {
if(!isxdigit(c)) bailout("character %c unrecognized, hex digit expected", c);
if(!isxdigit(s[1])) bailout("character %c unrecognized, hex digit expected", s[1]);
if(i >= REPDIAMETER) bailout("polyomino is too high, limit %d rows", REPDIAMETER);
piece[i] = (toHex(c)<<4) | toHex(s[1]);
piece[i] <<= 8;
s += 2;
if(*s == '+') ++s, piece[i] |= 0x80;
else if(*s == '{') {
++s;
if(!isxdigit(s[0]) || !isxdigit(s[1]) || s[2] != '}')
bailout("improper {xx} sequence for the second 8 bits", 0);
piece[i] |= toHex(s[0])<<4;
piece[i] |= toHex(s[1]);
s += 3;
}
if(!piece[i]) bailout("zero row in polyomino", 0);
mask |= piece[i];
nsq += nibbleCount[piece[i]>>12];
nsq += nibbleCount[(piece[i]>>8)&0xf];
nsq += nibbleCount[(piece[i]>>4)&0xf];
nsq += nibbleCount[(piece[i])&0xf];
++i;
} /* loop gathering the rows in this piece */

if(nsqFirst >= 0 && nsq != nsqFirst)
bailout("all polyominoes in the set must have the same number of squares", 0);
if(nsq > NSQ)
bailout("too many squares in the given polyomino, limit %d", NSQ);
nsqFirst = nsq;

by = i;
for(i=0; mask; ++i, mask<<=1)  ;
bx = i;

compileRotations(piece, bx, by);
if(pieceLocalMax < pieceMinMax) pieceMinMax = pieceLocalMax;

/* see if the checkerboard argument applies */
cbf = false;
if(!(nsq&1)) {
int total = 0;
for(i=0; i<by; ++i) {
mask = piece[i];
for(j=0; mask; ++j, mask<<=1) {
if(!isHighbit(mask)) continue;
if((i^j)&1) ++total; else --total;
}
}
if(total) cbf = true;
} /* even squares */
cbflag &= cbf;

/* which orientations are excluded at the walls? */
bo = lo = ro = 0xff;
if(*s == '~') {
c = *++s;
while(c && strchr("nulr", c)) {
if(c == 'n') bo &= ~0x11, lo &= ~0x88, ro &= ~0x22;
if(c == 'u') bo &= ~0x44, lo &= ~0x22, ro &= ~0x88;
if(c == 'l') bo &= ~0x82, lo &= ~0x41, ro &= ~0x14;
if(c == 'r') bo &= ~0x28, lo &= ~0x14, ro &= ~0x41;
wallRestrict = true;
c = *++s;
}
if(c && c != '_') bailout("n u l or r expected in ~ directive, %c unexpected", c);
}
bo_ok[setSize] = bo;
lo_ok[setSize] = lo;
ro_ok[setSize] = ro;

if(*s) ++s;
++setSize;
} /* loop over pieces in the set */

if(checkBits&ORIENTCHECK) {
struct ORIENT *o = o_leftlist;
for(i=0; i<o_max; ++i, ++o) {
printf("orient %d = %d %d %d %d %d %d %d%s /",
i, o->pno, o->ono,
o->w, o->h, o->x, o->y, o->breakLine,
(o->ambig ? "*" : ""));
for(j=0; j<o->w; ++j) {
printf("%x", o->pattern[j]);
if(j < o->w-1) printf(".");
}
bo = (bo_ok[o->pno] & (1<<o->ono));
lo = (lo_ok[o->pno] & (1<<o->ono));
ro = (ro_ok[o->pno] & (1<<o->ono));
if(!bo || !lo || !ro) {
printf(" ~");
if(!bo) printf("b");
if(!lo) printf("l");
if(!ro) printf("r");
}
printf("\n");
if(o->maxUnder) {
printf("under %d:", o->maxUnder);
for(j=0; j<o->w; ++j) {
printf("%x", o->under[j]);
if(j < o->w-1) printf(".");
}
printf("\n");
}
}
printf("setsize %d min %d max %d minmax %d\n",
setSize, setMinDimension, setMaxDimension, pieceMinMax);
}

stopgap = (setMinDimension&1) ? setMinDimension : setMinDimension - 1;
forgetgap = stopgap/2 - setMaxDimension/2 - 1;
if(forgetgap >= 0) bailout("forget gap should be negative, not %d", forgetgap);
} /* stringPiece */

/* find all the orientations of a piece */
static void compileRotations(shapebits *new, int bx, int by)
{
int swap; /* to swap bx and by */
int i, j, k;
int npat = 0;
shapebits patterns[8][REPDIAMETER];

for(j=0; j<2; ++j) { /* 2 reflections */
for(i=0; i<4; ++i) { /* 4 rotations */
if(by > setMaxDimension) setMaxDimension = by;
if(by > pieceLocalMax) pieceLocalMax = by;
if(by < setMinDimension) setMinDimension = by;

// with symmetry, there could be fewer than 8 distinct orientations.
for(k=0; k<npat; ++k)
if(!memcmp(patterns[k], new, REPDIAMETER*2)) {
if(i == 1 && j == 0) bailout("four fold symmetry on piece %d", setSize);
if(k == 0) {
// 180 degree rotation
if(i == 2 && j == 0) rotsym[setSize] |= 1;
// vertical reflection
if(i == 0 && j == 1) rotsym[setSize] |= 2;
// horizontal reflection
if(i == 2 && j == 1) rotsym[setSize] |= 4;
}
break;
}
if(k == npat) {
// this one is new
memcpy(patterns[npat], new, REPDIAMETER*2);
++npat;
compilePiece(new, bx, by, 4*j+i);
}

clockwise(new);
swap = bx, bx = by, by = swap;
} /* loop over rotations */

vertReflect(new);
} /* loop over reflections */
if(npat == 2) bailout("too much symmetry on piece %d", setSize);
} /* compileRotations */

/*********************************************************************
Rotation established, compile the piece.
When we read the piece from the config file, the bits are left justified
in the short. We want them to be right justified, low order bits.
Also, the words should be columns, not rows.
So compileRotations is passing us a shape, but we're going to reflect and
rotate it before we store it in o_leftlist.
On the first call, the piece is as it appears in the config file,
but we reflect the bits, then trade columns and rows,
which is a clockwise rotation,
so if it comes in as 0 it goes to o_leftlist as 7.
Next time the piece is rotated clockwise,
so reflect and clockwise again, and that is the same as a base reflection, or 4.
The convert orientation array performs this magic,
make sure it makes sense to you before you proceed.
*********************************************************************/

static const uchar convert_ono[8] = {7,4,5,6,1,2,3,0};

static void compilePiece(const shapebits *new, int bx, int by, int ono)
{
struct ORIENT *o = o_leftlist + o_max;
struct ORIENT *q;
int i, j, k;
shapebits mask;

if(o_max == O_MAX) bailout("too many orientations, limit %d", O_MAX);
for(j=0; j<by; ++j)
if(isHighbit(new[j])) break;
if(j == by) bailout("compilePiece finds no high bit %d", by);

o->h = bx;
o->w = by;
o->ambig = false;
o->x = j;
o->y = 0;
o->pno = setSize;
o->ono = convert_ono[ono];
o->key = o_max*2;
for(j=0; j<by; ++j)
o->pattern[j] = reverseShort(new[j]);

/* compute the break level */
o->breakLine = (o->h-1)/2;
if(!(o->h&1)) { /* even, requires further refinement */
// See which half is "heavier".
// This is a center of mass calculation.
// But simple moment makes e0b0 ambiguous, so give extra weight
// to the squares near the outside of the piece.
int bottom = 0, top = 0;
int shift, subtotal, side;
for(j=0; j<by; ++j) {
shapebits v = new[j];
for(mask=HIGHBIT, shift=0; shift<bx; ++shift, mask>>=1) {
if(!(v&mask)) continue;
k = shift - o->breakLine;
if(k <= 0) --k;
subtotal = (k*k << 8);
side = by/2 - j;
if(side <= 0 && !(by&1)) --side;
if(side < 0) side = -side;
subtotal += side;
if(k < 0) bottom += subtotal; else top += subtotal;
}
}
// set ORIENTCHECK to see which pieces are ambiguous
if(bottom == top) o->ambig = true;
if(bottom < top) ++o->breakLine;
} /* even straddle */

reflectCompiledPiece();

/* Find all the other lower left corners. */
for(i=0; i<o->w; ++i) {
if(i == o->x) continue; /* we already did this one */
for(j=0; j<o->h; ++j) {
mask = 1<<j;
if(o->pattern[i]&mask) break;
}
if(j == o->h) bailout("j bit not found at column %d", i);
if(i && o->pattern[i-1]&mask) continue;
/* we just found another lower left corner */
if(o_max == O_MAX) bailout("too many orientations, limit %d", O_MAX);
q = o_leftlist + o_max;
*q = *o; /* structure copy */
q->x = i;
q->y = j;
q->breakLine -= j;
q->key = o_max*2;
reflectCompiledPiece();
}
} /* compilePiece */

/* reflect a compiled piece, left to right */
static void reflectCompiledPiece(void)
{
int i, j;
shapebits v;
bool change;
struct ORIENT *o = o_leftlist + o_max;
struct ORIENT *p = o_rightlist + o_max;

p->h = o->h, p->w = o->w, p->ambig = o->ambig;
p->pno = o->pno;
p->ono = hrefOrient[o->ono];
p->key = o->key + 1;
p->x = o->w-1 - o->x;
p->y = o->y, p->breakLine = o->breakLine;

// We're not just reflecting, we're doing some calculations.
// under looks like a negative image of the piece, at least from below.
o->maxUnder = 0;
for(i=0; i<o->w; ++i) {
for(v=1, j=0; !(v&o->pattern[i]); v<<=1, ++j)  ;
o->under[i] = v-1;
if(j > o->maxUnder) o->maxUnder = j;
}

// now we worm our way around, in case the shape isn't convex.
// Think of ff7a30 pointing down, we have to fill in the notch of 7a.
// This is real inefficient but who cares.
if(o->maxUnder) {
change = true;
while(change) {
change = false;
for(i=0; i<o->w; ++i) {
for(j=0, v=1; j<o->h; ++j, v<<=1) {
if(o->under[i]&v) continue;
if(o->pattern[i]&v) continue;
// not in the pattern or its negative
if(i && o->under[i-1]&v ||
i < o->w-1 && o->under[i+1]&v ||
j && o->under[i]&(v>>1) ||
j < o->h-1 && o->under[i]&(v<<1)) {
o->under[i] |= v;
if(j > o->maxUnder) o->maxUnder = j;
change = true;
}
}
}
}
}

p->maxUnder = o->maxUnder;
for(i=0; i<o->w; ++i) {
p->pattern[o->w-1-i] = o->pattern[i];
p->under[o->w-1-i] = o->under[i];
}

++o_max; // on to the next orientation
} /* reflectCompiledPiece */

// Sort orientations on y, then width-x, the stuff to the right of the corner.
// Also populate o_midlist and the other lists.
static void sortOrientations(void)
{
struct ORIENT swap;
struct ORIENT *a, *b;
int i, j;
bool change;

change = true;
while(change) {
change = false;
for(i=0; i<o_max-1; ++i) {
a = o_leftlist+i;
b = a+1;
if(a->y < b->y) continue;
if(a->y == b->y && a->w - a->x <= b->w - b->x) continue;
swap = *a, *a = *b, *b = swap;
a = o_rightlist + i;
b = a+1;
swap = *a, *a = *b, *b = swap;
change = true;
}
}

for(i=0; i<o_max; ++i) {
a = o_leftlist+i;
// replace ono with its bit, easier for masking
a->ono = 1<<a->ono;
a->rotsym = rotsym[a->pno];
a = o_rightlist + i;
a->ono = 1<<a->ono;
a->rotsym = rotsym[a->pno];
}
o_sizes[0] = o_sizes[1] = o_max;

j = 0;
for(i=0; i<o_max; ++i) {
a = o_leftlist + i;
if(a->x < a->w-1 &&
a->pattern[a->x+1] & (1<<(a->y))) continue;
b = o_midlist + j;
*b = *a;
++j;
}
o_sizes[2] = j;

j = 0;
for(i=0; i<o_max; ++i) {
a = o_leftlist + i;
if(a->x < a->w-1 &&
a->pattern[a->x+1] & (3<<(a->y))) continue;
if(a->x &&
a->pattern[a->x-1] & (3<<(a->y))) continue;
b = o_mid2list + j;
*b = *a;
++j;
}
o_sizes[9] = j;

j = 0;
for(i=0; i<o_max; ++i) {
a = o_leftlist + i;
if((a->pattern[a->x]>>a->y) & 2) continue;
b = o_l1list + j;
*b = *a;
a = o_rightlist + i;
b = o_r1list + j;
*b = *a;
++j;
}
o_sizes[3] = o_sizes[4] = j;

j = 0;
for(i=0; i<o_max; ++i) {
a = o_leftlist + i;
if(a->x && (a->pattern[a->x-1]>>a->y) & 2) continue;
b = o_l2list + j;
*b = *a;
a = o_rightlist + i;
b = o_r2list + j;
*b = *a;
++j;
}
o_sizes[5] = o_sizes[6] = j;

j = 0;
for(i=0; i<o_max; ++i) {
a = o_leftlist + i;
if(a->x && (a->pattern[a->x-1]>>a->y) & 6) continue;
b = o_l3list + j;
*b = *a;
a = o_rightlist + i;
b = o_r3list + j;
*b = *a;
++j;
}
o_sizes[7] = o_sizes[8] = j;

// print out ambiguous pieces
for(i=0; i<o_max; ++i) {
a = o_leftlist + i;
if(!a->ambig) continue;
// if the piece is symmetric, ambiguity is unavoidable. I only want to call
// attention to ambiguity that shouldn't be there.
if(a->rotsym&1) continue; // 180 degree symmetry
if(a->rotsym&2 && (a->ono == 1 || a->ono == 4)) continue;
if(a->rotsym&4 && (a->ono == 0x20 || a->ono == 0x80)) continue;
printf("piece %d is unexpectedly ambiguous orient %x sym %d\n", a->pno, a->ono, a->rotsym);
}

if(checkBits&ORIENTCHECK) {
printf("sorted %d %d %d %d %d %d\n",
o_sizes[0], o_sizes[2], o_sizes[9], o_sizes[3], o_sizes[5], o_sizes[7]);
exit(0);
}
} /* sortOrientations */

static void demo_ccp(void)
{
struct ORIENT *o;
int i, j, key, dy, lr;
printf("switch((o->key<<4) + dy) {\n");
for(i=0; i<o_max; ++i) {
for(lr=0; lr<2; ++lr) {
o = (!lr ? o_leftlist + i : o_rightlist + i);
key = o->key;
for(dy=0; dy<16; ++dy) {
printf("case %d:\n", (key<<4)+dy);
if(dy <= 12) {
if(o->x) printf("b = b0 + i - %d;\n", o->x);
else puts("b = b0 + i;");
for(j=0; j<o->w; ++j) {
printf("if(*b & 0x%x) continue;\n", (o->pattern[j]<<dy));
if(j < o->w-1) puts("++b;");
}
}
puts("break;");
}
}
}
puts("} // end switch");
puts("x0 = i - o->x;");
exit(0);
}

// We have the software to parse the piece string and compile the orientations,
// so let's read the config file.

static int restart = 0; // depth when resuming the analysis
static int restartParent;
static int startMega;
static int numThreads;
static int lookahead; /* look ahead this many rows when tiling */
static char r_shorts; // nodes must use shorts, rather than bytes
static void demo_ccp(void);
#define BADSPANCOUNT 10
static struct BADSPAN { schar drop, span, up, filler; } badSpan[BADSPANCOUNT+1];

static void readConfig(void)
{
FILE *f;
char line[BOARDWIDTH+10];
int lineno = 0;
int i, j;
char *s;
char c;
struct BADSPAN *sp;

f = fopen (config, "r");
if(!f) bailout("unable to open, errno %d", errno);

while(fgets(line, sizeof(line), f)) {
++lineno;
j = strlen(line);
if(!j) bailout("line %d, fgets returned an empty string", lineno);
--j;
s = line + j;
if(*s != '\n') bailout("line %d, line is too long", lineno);
*s = 0;

s = strchr(line, '#');
if(s) *s = 0;
for(i=j=0; (c = line[i]) != 0; ++i)
if(!isspace(c)) line[j++] = c;
line[j] = 0;
if(!j) bailout("line %d, no content", lineno);

if(!strcmp(line, "-")) { --lineno; break; }

switch(lineno) {
case 1:
stringPiece(line);
if(setMaxDimension > 9) r_shorts = 1;
if(checkBits&CCP) demo_ccp();
sortOrientations();
break;

case 2:
curWidth = strtol(line, &s, 10);
if(*s == 'a') ++s, checkBits |= LOOKALLCHECK;
if((*s && *s != '@') || curWidth < 4 || curWidth > 250)
bailout("line %d, expected an initial width between 4 and 250", lineno);
if(*s == '@') {
++s;
restart = strtol(s, &s, 10);
if(*s || restart <= 0 || restart > 1000)
bailout("line %d, expected a restart value between 1 and 1000", lineno);
}
break;

case 3:
bestOrder = strtol(line, &s, 10);
if(*s || bestOrder < 4 || bestOrder > 30000)
bailout("line %d, expected an order between 4 and 30000", lineno);
break;

case 4:
startMega = strtol(line, &s, 10);
if(*s == 'a') ++s, checkBits |= ALLCACHE;
if(*s || startMega < 1 || startMega > 400)
bailout("line %d, expected a mega-node count between 1 and 400", lineno);
break;

case 5:
numThreads = strtol(line, &s, 10);
if(*s == 's') ++s, checkBits |= SHOWTHREAD;
if(*s || numThreads < 0 || numThreads > NUMTHREADS)
bailout("line 5, expected a thread count between 1 and %d", NUMTHREADS);
break;

case 6:
lookahead = strtol(line, &s, 10);
if(*s || lookahead < 1 || lookahead > 4)
bailout("line %d, expected a lookahead value between 1 and 4", lineno);
break;

case 7:
ordFactor = strtol(line, &s, 10);
if(*s || ordFactor < 1 || ordFactor > 1000)
bailout("line %d, expected a factor between 1 and 1000", lineno);
if(cbflag & ordFactor) {
printf("checkerboard upgrade from %d to %d\n", ordFactor, ordFactor*2);
ordFactor *= 2;
}
bestOrder -= (bestOrder%ordFactor);
break;

case 8:
dimFactor = strtol(line, &s, 10);
if(*s || dimFactor < 1 || dimFactor > 60)
bailout("line %d, expected a factor between 1 and 60", lineno);
if(dimFactor > 1) {
curWidth += dimFactor-1;
curWidth -= curWidth%dimFactor;
}
curWidth1 = curWidth + 1;
curNodeWidth = curWidth * (1+r_shorts);
break;

case 9:
// This feature, forbidden spans, is suppose to make things faster,
// but it actually slows things down, so don't use it.
sp = badSpan, s = line;
while(*s) {
if(sp - badSpan >= BADSPANCOUNT) bailout("too many bad spans, limit %d", BADSPANCOUNT);
sp->drop = strtol(s, &s, 10); if(*s == ',') ++s;
sp->span = strtol(s, &s, 10); if(*s == ',') ++s;
sp->up = strtol(s, &s, 10);
if(*s && *s != '|' || sp->drop <= 0 || sp->span <= 0 || sp->up <= 0)
bailout("syntax error, please enter a series of bad spans down,span,up separated by pipes", 0);
++sp;
if(*s) ++s;
}
break;

default:
bailout("more than 8 lines in the config file", 0);
} /* switch on lineno */
} /* reading lines in the config file */
fclose(f);

if(!lineno) bailout("file is empty", 0);
if(lineno < 7) bailout("file does not contain enough lines of configuration data, 7 lines expected", 0);
} /* readConfig */

/* find the lowest empty bit in a short */
static char lowEmpty[65536];
static void lowEmptySet(void)
{
ushort mask;
int j, k;
for(j=0; j<65536; ++j) {
mask = j;
for(k=0; mask&1; ++k, mask>>=1)  ;
lowEmpty[j] = k;
}
} /* lowEmptySet */

// signal handlers
static uchar inPause = 0, inTerm = 0;
static void catchInt(int n)
{
inPause = 1;
if(!isatty(0)) inTerm = 1;
if(n != SIGINT) inTerm = 1; // should never happen
// recatch the signal from within the foreground thread
signal(SIGINT, catchInt);
printf(" pause");
} /* catchInt */

static void catchTerm(int n)
{
inTerm = 1;
}

/*********************************************************************
I store nodes on disk, and a cache in memory.
I support up to 60 data files, each 2 gig - that's 120 gig of data.
This can hold as many as a billion nodes.
*********************************************************************/

static int fd[60] = // the file descriptors
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};
static char filename[120];
static long nodesInFile;
static long nodesDisk; // nodes stored on disk
static long nodesCache; // nodes stored in cache
static int megaNodes; // millions of nodes that can be cached
static long maxNodes; // megaNodes times a million
static long slopNodes; // maxNodes plus some slop for the randomness of the hash
static int hwm; // high water mark on the cache
static long nodesPending; // nodes yet to process
static long lastDisk;
static long mon_idx; // for markOldNodes()
static long nodeStep;
static int workStep;
static bool noincrease;

pthread_mutex_t nodeAccess = PTHREAD_MUTEX_INITIALIZER;
#define ThreadLock if(numThreads)    pthread_mutex_lock( &nodeAccess )
#define ThreadUnlock if(numThreads)    pthread_mutex_unlock( &nodeAccess )

/*********************************************************************
We expande node A at depth 25, and generate node Z at depth 27.
Later on we generate node B at depth 26.
Next we analyze all the nodes at depth 26 in order.
Node B generates the very same node Z, but this time at depth 26. When this
happens we downgrade the depth and give it the new parent, B instead of A.
However, in my example Z now has depth 26 and should be expanded.
But we have already passed by Z, so it won't be analyzed.
To get around this, I put Z on a work list.
You need to finish the work list before you move on to depth 27.
Note - this has never happened in the 20 years I have run this program.
The code hasn't even been tested. You'll see < in the output if it ever happens,
then > in the output when this reclassified node is expanded.
Obviously < and > should balance.
initFiles() allocates the workList array.
It can grow if necessary, but as I say, it has never been used even once.
*********************************************************************/

static long *workList; // the list of discovered nodes to expand
static int workEnd, workAlloc;
static void initFiles(void);

static void appendWorkList(long idx)
{
if(workEnd == workAlloc) {
workAlloc = workAlloc/2 * 3;
workList = erealloc(workList, sizeof(long)*workAlloc);
}
workList[workEnd++] = idx;
printf("<");
// This node was pending before and is still pending so nodesPending doesn't change.
} /* appendWorkList */

/*********************************************************************
Entry point.
Read the config file.
Loop over valid rectangle widths. {
Initialize disk files.
Expand the first node, the floor of the rectangle.
Repeatedly expand all nodes until the rectangle grows too high.
}

You can hit ^c to get some runtime control over the program.
It will say pause and ask you what to do.
Type h for help, or review the switch statement below,
it's prety straightforward.
If you know you have to shut down the computer, it's best to quit gracefully,
^c and then q, so you can restart the program later with the @ feature.
*********************************************************************/

static void quadTest(void) ;
static void oenTest(void) ;
static void expandFirstNode(void) ;
static void expandNodes(void) ;
static void markOldNodes(void) ;

int main(int argc, const char **argv)
{
int j;

nice(20);

/* undocumented -bitmask option not intended for the user */
if(argc >= 2 && argv[1][0] == '-') {
checkBits = strtol(argv[1]+1, 0, 16);
++argv, --argc; }

lowEmptySet();

if(argc == 2 && argv[1][0] == '@') {
/* polyomino on the command line, quadrant test */
stringPiece(argv[1]+1);
quadTest();
}

if(argc == 2 && argv[1][0] == '^') {
/* polyomino on the command line, other values default. */
stringPiece(argv[1]+1);
if(setMaxDimension > 9) r_shorts = 1;
if(checkBits&CCP) demo_ccp();
sortOrientations();
curWidth = setMinDimension;
bestOrder = 4000;
startMega = 2;
lookahead = 1;
ordFactor = (cbflag ? 2 : 1);
dimFactor = 1;
curWidth1 = curWidth + 1;
curNodeWidth = curWidth * (1+r_shorts);
piecename = argv[1] + 1;
goto config_set;
}

if(argc != 2 || argv[1][0] == '-')
bailout("usage:  trec config_file", 0);

config = piecename = argv[1];
readConfig();
config = 0;

config_set:
sprintf(filename, "dotile/%s", piecename);
mkdir(filename, 0777);
sprintf(filename, "dotile/%s/data-x", piecename);

fflush(stdout);
setbuf(stdout, 0);

if(!bestOrder) oenTest();

signal(SIGTERM, catchTerm);
signal(SIGQUIT, catchTerm);
signal(SIGINT, catchInt);
signal(SIGHUP, SIG_IGN);

while(true) {
if(curWidth*curWidth > bestOrder*nsq) break;
setBestRow();
if(bestRow >= curWidth) {
initFiles();
setBestRow();
printf("?%d", curWidth);
if(!curDepth) expandFirstNode();
if(nodesPending) { /* we got some nodes off the floor */
do {
printf(" @");
if(!restart) markOldNodes();
printf("%d", curDepth);
j = nodesCache / (maxNodes/10);
if(j != hwm) { hwm = j; printf(" %%%d0", j); }
expandNodes();

if(inTerm) {
if(workStep < workEnd) printf(" workAlloc nodes are unprocessed");
exit(0);
}

restart = 0;
restartParent = 0;
++curDepth;
setBestRow(); /* also resets leastRow */
if(stopsearch) break;
if(bestRow < curWidth && !(checkBits&LOOKALLCHECK)) break;
} while(nodesPending);
}
printf(" :%ld\n", nodesCache);
}

restart = 0;
restartParent = 0;
noincrease = false;
curWidth += dimFactor;
if(curWidth > BOARDWIDTH-2) bailout("width cannot exceed %d", BOARDWIDTH-2);
curWidth1 = curWidth + 1;
curNodeWidth = curWidth * (1+r_shorts);
}

return 0;
} /* main */

// special code to keep certain pieces and/or orientations away from the walls
static inline bool wallTest(const struct ORIENT *o, int x0, int y0)
{
if(!curDepth && !y0 &&
!(o->ono&bo_ok[o->pno])) goto fail;
if(x0 == 1 &&
!(o->ono&lo_ok[o->pno])) goto fail;
if(x0+o->w == curWidth1 &&
!(o->ono&ro_ok[o->pno])) goto fail;
return true;
fail:
return false;
} /* wallTest */

// See if there is a small unfillable hole beneath the piece you want to place
static inline bool holeTest(const shapebits *b0, const struct ORIENT *o, int x0, int y0)
{
const shapebits *pat;
const shapebits *b, *b_start, *b_end;
shapebits mask, dymask;
uchar understate = 0;
// 1 means a wall up to the bottom of the first piece,
// 2 is a gap after the first wall
const shapebits *holestart = 0;

/* Look for holes below the piece, and mark left and right inlets */
b_start = b = b0 + x0;
b_end = b_start + o->w;
pat = o->under;
/* does the board present a wall just to the left of this piece? */
dymask = (1<<y0) - 1;
mask = (*pat<<y0) | dymask;
if((b[-1]&mask) == mask) ++understate;
/* now march along the piece looking at under */
do {
mask = (*pat<<y0) | dymask;
if((*b&mask) == mask) {
/* wall up to the bottom of the new piece */
if(understate == 2) goto holeFound;
understate = 1;
} else {
if(understate == 1) ++understate, holestart = b;
}
} while(++pat, ++b != b_end);
/* and the border on the right */
if(understate == 2 && (*b&mask) == mask) {
holeFound:
// This routine is not called unless we already know the piece cannot
// stand up; just see if it can lie down.
if(b-holestart < pieceMinMax) return false;
}

#if 0
if(badSpan[0].drop && y0 == min_y) {
// look for forbidden gaps on the floor
const shapebits *g_start, *g_end;
int drop = 0, span, up, lastlev = -1, ly;
const struct BADSPAN *sp;
g_start = b0 + x0 - 5;
if(g_start < b0) g_start = b0;
g_end = b0 + x0 + o->w + 5;
if(g_end > b0 + curWidth1) g_end = b0 + curWidth1;
pat = o->pattern;
for(b=g_start; b<g_end; ++b) {
mask = *b;
if(b >= b_start && b < b_end) mask |= (*pat++ < y0);
ly = lowEmpty[mask];
if(ly < lastlev) {
// can't have anything hanging over above the gap
if(mask >> ly) drop = 0;
else drop = lastlev - ly, span = 1;
lastlev = ly;
continue;
}
if(ly == lastlev) {
if(drop) {
++span;
if(mask >> ly) drop = 0;
}
continue;
}
if(!drop) goto nospan;
up = ly - lastlev;
for(sp=badSpan; sp->drop; ++sp)
if(sp->span == span && (drop >= sp->drop && up >= sp->up || drop >= sp->up && up >= sp->drop))
break;
if(sp->drop) return false; // found a forbidden span
nospan:
lastlev = ly, drop = 0;
}
}
#endif

  return true;
} /* holeTest */

#if 0
// check for forbiddne spans
static inline bool spanTest(const shapebits *b0, const struct ORIENT *o, int x0, int y0)
{
const shapebits *g_start, *g_end, *b;
int drop = 0, span, up, lastlev = -1, ly, j;
const struct BADSPAN *sp;
g_start = b0 + x0 - 5;
if(g_start < b0) g_start = b0;
g_end = b0 + x0 + o->w + 5;
if(g_end > b0 + curWidth1) g_end = b0 + curWidth1;
for(b=g_start; b<g_end; ++b) {
ly = lowEmpty[*b];
if(ly < lastlev) {
drop = lastlev - ly, span = 1;
lastlev = ly;
continue;
}
if(ly == lastlev) {
++span;
continue;
}
if(!drop) goto nospan;
up = ly - lastlev;
for(sp=badSpan; sp->drop; ++sp)
if(sp->span == span && (drop >= sp->drop && up >= sp->up || drop >= sp->up && up >= sp->drop))
break;
if(!sp->drop) goto nospan;
// can't have anything hanging over above the gap
for(j=1; j<=span; ++j)
if(b[-j]>>lastlev) goto nospan;
return false;
nospan:
lastlev = ly, drop = 0;
}
return true;
}
#endif

// Here is the structure for the node.
struct NODE {
long parent; // where this node came from
long hash; // hash value of this pattern
short depth; // the depth of this node
uchar gap; // the gap of this pattern
bool dead;
union {
uchar b[BOARDWIDTH]; // bytes
ushort s[BOARDWIDTH]; // shorts
} pattern;
};

static int nodeSize; // adjusted for the actual width

static void readNode(long idx, struct NODE *buf)
{
int i = idx / nodesInFile;
long offset = (idx%nodesInFile) * nodeSize;
elseek(fd[i], offset);
eread(fd[i], buf, nodeSize);
} /* readNode */

static void writeNode(long idx, const struct NODE *buf)
{
int i = idx / nodesInFile;
long offset = (idx%nodesInFile) * nodeSize;
elseek(fd[i], offset);
ewrite(fd[i], buf, nodeSize);
} /* writeNode */

// Get the next node to expand
static void interactive(void);
static long getNode(struct NODE *buf)
{
int n;

if(inTerm) return 0;

ThreadLock;

/*********************************************************************
Check for ^c interactive access here.
A thread asks for the next node and that thread stops and waits for user input.
Because of the mutex, the other threads, quickly, we hope,
finish their expansion and ask for the next node, and wait behind this one.
The entire process stops.
When this user hits return this thread gets another node to work on,
and the other threads get nodes to work on, and we resume.
*********************************************************************/

if(inPause) {
interactive();
inPause = 0;
}

while(nodeStep < nodesDisk || workStep < workEnd) {
if(workStep < workEnd) {
n = workList[workStep++];
printf(">");
} else n = nodeStep++;
readNode(n, buf);
if(buf->dead) continue;
if(buf->depth != curDepth) continue;
if(checkBits&PERFORMCHECK) {
static int pcnt = 0;
if(++pcnt == 1000) {
printf("+%d", nodesDisk - lastDisk);
lastDisk = nodesDisk;
pcnt = 0;
}
}
// Sanity check, but these things should never happen.
if(nodesPending < 0)
bailout("pending negative %d", nodesDisk - nodeStep);
if(nodesCache < 0)
bailout("nodesCache negative %d", nodesCache);
if(!nodesCache && curDepth)
bailout("nothing in cache, %d pending", nodesPending);
ThreadUnlock;
return n;
}

ThreadUnlock;
return 0;
}

// The things you can watch and change at runtime
static bool showdots;
static void interactive(void)
{
int j;
char getbuf[12];
fgets(getbuf, 12, stdin);
switch(getbuf[0]) {
case 'q':
// as though the process were killed
inTerm = 1;

case 'p':
checkBits ^= PERFORMCHECK;
lastDisk = nodesDisk;
break;

case 'l':
if(getbuf[1] == '\n') printf("%d", lookahead);
if(isdigit(getbuf[1])) {
lookahead = getbuf[1] - '0';
if(lookahead > 4) lookahead = 4;
if(lookahead < 1) lookahead = 1;
}
break;

case 'r':
printf("%s ?%d@%d ^%d t%d",
piecename, curWidth, curDepth, megaNodes, numThreads);
break;

case 'a':
checkBits ^= LOOKALLCHECK;
if(checkBits&LOOKALLCHECK) printf("back solutions");
else printf("no back solutions");
break;

case 'd':
showdots ^= 1;
break;

case 'n':
printf(" %d nodes, %d this, %d pending, %d cache\n",
nodesDisk, nodeStep, nodesPending, nodesCache);
break;

case 'b':
if(getbuf[1] == '\n') printf("%d", bestOrder);
if(isdigit(getbuf[1])) {
j = atoi(getbuf+1);
if(j > bestOrder && noincrease) {
printf("cannot increase the bound\n");
} else {
bestOrder = j;
setBestRow();
}
}
break;

case 'h':
printf("h help, q quit, p performance, d dots, l lookahead, r restart information, a allcheck, n node counts, b best order");
break;

default:
printf("what");
} /* switch */

printf(" resume");
}

/*********************************************************************
Expand the node using the algorithm described at the top of this file.
A stack of structures tracks the placement of the pieces on the board.
This is where the rubber meets the road.
This routine makes a copy of the board on-stack, so that it is threadsafe.
One thread expands one node, another thread expands another, etc.
*********************************************************************/

struct PLACE {
short x, y; // location of this piece
uchar oidx; // orientation index
uchar otop;
short myc;
const struct ORIENT *o;
const struct ORIENT *olist;
uchar breakLine; // before we placed this piece
uchar min_y;
short choices;
ulong orients[3]; // bitmap of viable orientations
};

static void markOldNode(long jdx, long hash);
static bool findNode( struct NODE *look, bool insert, struct NODE *dest);
static void matchFound(const struct NODE *left, const struct NODE *right) ;
static int reachup; /* greatest reach of node so far */

static void expandNode(long this_idx, const uchar *base_b)
{
ushort *base_s = (ushort*)base_b;
int lev; /* placement level */
struct PLACE *p;
const struct PLACE *q;
const struct ORIENT *o, *o_start, *o_end;
const shapebits *pat;
shapebits *b; // pointer to test, place, and unplace the piece
const shapebits *b_end;
int i, j;
shapebits mask;
shapebits onleft, onright;
shapebits thisval;
int ly; /* location y coordinate */
int min_y, min_y_count;
shapebits min_y_bit;
int dy; /* delta y, shift the piece up this much */
int x0; /* b_start - b0 */
int best_x, best_y, best_val;
uchar whichlist;
const struct ORIENT *best_olist;
int best_otop;
int reset = -1;
int breakLine = setMaxDimension/2 + 1;
int prevStart, prevEnd;
int searchStart, searchEnd, searchPass;
bool children = false;
bool ambinclude, ambnode;
ulong orients[3]; /* bitmap of viable orientations */
/*********************************************************************
The primary board, padded on the left and with a border on the right.
Why the padding? Consider the collision test. Does a piece collide
with other pieces, or the edge of the board? I run this test left to right,
but the left end of the piece could be well past the left edge of the board,
as when a gun tries to lie down in the lower left corner and its barrel pokes
beyond the left wall and into uncharted territory.
I pad this region with ones so the test will simply fail, and not seg fault.
*********************************************************************/
shapebits b0pad[REPDIAMETER+BOARDWIDTH];
// b0 is the actual board, with a border at b0[0] and b0[curWidth1]
#define b0 (b0pad+REPDIAMETER)
shapebits b1[BOARDWIDTH];
struct NODE newnode, compnode, looknode;
struct PLACE placeTry[BOARDWIDTH];

min_y = 0;
min_y_bit = 1;
min_y_count = 0;
// copy the board to the board on-stack for manipulation
if(r_shorts) {
for(j=0; j<curWidth; ++j) {
if(!(base_s[j]&1)) ++min_y_count;
b0[j+1] = base_s[j];
}
} else {
for(j=0; j<curWidth; ++j) {
if(!(base_b[j]&1)) ++min_y_count;
b0[j+1] = base_b[j];
}
}
memset(b0pad, 0xff, (REPDIAMETER+1)*sizeof(shapebits));
b0[curWidth1] = 0xffff;

if(checkBits&NODECHECK) {
printf("node count %d\n", nodesDisk);
printf("expand "); showPattern(b0+1); printf("\n");
}

p = placeTry - 1, lev = -1;

advance:
if(++lev >= BOARDWIDTH)
bailout("placement stack overflow", 0);
++p;
j = breakLine;
// If we tiled rows 0 through j-1, the first j rows, we're done.
// But allow for some lookahead.
// I tested a little bit at lookahead = 0, and things seem to work,
// but everything seems better with lookahead at least 1,
// so we always go one more row than we have to.
j += lookahead;
if(min_y >= j) goto complete;

/* find location to place the piece */
best_x = 0;
best_val = O_MAX+1;

/* It helps if we look near the last piece placed. */
/* That's most likely to create an unfillable hole. */
if(lev) {
q = p - 1;
o = q->o;
prevStart = q->x - o->x;
prevEnd = prevStart + o->w;
prevStart -= 2;
if(prevStart <= 0) prevStart = 1;
prevEnd += 2;
if(prevEnd > curWidth1) prevEnd = curWidth1;
} else {
prevStart = 1, prevEnd=curWidth1;
}

for(searchPass=1; searchPass <= 3; ++searchPass) {
if(searchPass == 1) {
searchStart = prevStart;
searchEnd = prevEnd;
}
if(searchPass == 2) {
if(prevEnd == curWidth1) continue;
searchStart = prevEnd;
searchEnd = curWidth1;
}
if(searchPass == 3) {
if(prevStart == 1) continue;
searchStart = 1;
searchEnd = prevStart;
}

for(i=searchStart; i<searchEnd; ++i) {
thisval = b0[i];
ly = lowEmpty[thisval];
if(ly > min_y+3) goto nextColumn; // too high
if(ly > 12) goto nextColumn;
mask = 1<<ly;
onleft = b0[i-1] & mask;
onright = b0[i+1] & mask;
if(!(onleft|onright)) goto nextColumn;

whichlist = !onleft;
if(thisval&(mask<<1)) whichlist += 3;
else if(onleft&onright) whichlist = 2;

// All these extra lists improve timing maybe 1%, which isn't exciting.
if(whichlist < 2) {
if(onleft) {
if(b0[i-1] & (mask<<1)) {
whichlist = 5;
if(b0[i-1] & (mask<<2))
whichlist = 7;
}
} else {
if(b0[i+1] & (mask<<1)) {
whichlist = 6;
if(b0[i+1] & (mask<<2))
whichlist = 8;
}
}
}
if(whichlist == 2) {
if(b0[i-1] & b0[i+1] & (mask<<1))
whichlist = 9;
}

o_start = o = o_whichlist[whichlist];
o_end = o + o_sizes[whichlist];
if(o_end == o) goto backup;

clearOrientBits(orients);
j = 0; /* count viable orientations */

do {
/* collision test, does this piece collide with the border or another piece? */
dy = ly - o->y;
/* This is the point where we assume the orientations are sorted */
if(dy < min_y) break;
x0 = i - o->x;
b = b0 + x0;
if(*b & (o->pattern[0]<<dy)) continue;
if(b[1] & (o->pattern[1]<<dy)) continue;
if(o->w > 2) {
b_end = b + o->w;
b += 2;
pat = o->pattern + 2;
do if(*b & (*pat<<dy)) goto nextOrient; while(++pat, ++b != b_end);
}

/* We can be tiling up through 10 rows, and the piece could be 9 in height.
 * That's 18, so some of the pieces might shift off the board.
 * That causes the above collision test to create some false positives,
 * because it doesn't detect collisions that occur "off the board",
 * but that's ok - false negatives are unacceptable.
 * I take the same philosophy here.
 * If we can rule out an orientation because it traps a hole underneath,
 * great, but if we're not sure, let it pass through.
 * That means the placed piece has to have some space
 * under it, but it can't be so high off the floor that
 * other pieces might actually stand up beneath it,
 * or the hole slides off the edge of the board. */

// could there be empty space beneath?
if((dy > min_y || o->maxUnder)  &&
/* no piece can stand up below this one */
dy + o->maxUnder - min_y < pieceMinMax &&
/* all representible in 15 bits */
dy + o->maxUnder < REPDIAMETER &&
// it's ok to run the hole test now
!holeTest(b0, o, x0, dy)) goto nextOrient;

if(wallRestrict && !wallTest(o, x0, dy)) continue;

++j;
// If this piece is above the levels we have already tiled, and there are a lot
// of orientations to choose from, we're better off
// choosing a square at a lower level.
// As this is written, we only place a square at a higher level if there is
// no choice, board is impossible, or just one choice.
if(j > 1 && ly > min_y) goto nextColumn;
// do we already have something better, i.e. fewer choices/
if(j >= best_val) goto nextColumn;
setOrientBit(orients, o-o_start);
nextOrient: ;
} while(++o != o_end); /* loop over orientations */

// if we can't place any piece here then the last piece must be wrong
if(!j) goto backup;
best_x = i;
best_y = ly;
best_val = j;
best_olist = o_start;
best_otop = o_end - o_start;
// remember the valid orientations, don't compute them again
copyOrientBits(p->orients, orients);

// if just one choice then make it
if(j == 1) goto squareSelected;

// If this piece isn't near the last piece placed, then just place it.
// It probably doesn't help much to scan across he entire board.
if(searchPass > 1) goto squareSelected;

nextColumn: ;
} /* loop across the board */

if(best_x) goto squareSelected;
} /* three search passes */

squareSelected:
if(!best_x) {
printf("\n");
showPattern(b0);
bailout("\nbest_x not selected, min_y = %d", min_y);
}
p->x = best_x;
p->y = best_y;
p->choices = best_val;
p->olist = best_olist;
p->otop = best_otop;
p->breakLine = breakLine;
p->min_y = min_y;
p->myc = min_y_count;
p->oidx = -1;
if(checkBits&NODECHECK)
printf("choice %d.%d=%x\n",
p->x-1, p->y, p->orients[0]);

next:
if(++p->oidx >= p->otop) goto backup;
if(!testOrientBit(p->orients, p->oidx)) goto next;
p->o = o = p->olist + p->oidx;

/* place the piece */
pat = o->pattern;
b = b0 + p->x - o->x;
b_end = b + o->w;
dy = p->y - o->y;
do {
shapebits t = (*pat<<dy);
if(t&min_y_bit) --min_y_count;
*b |= t;
} while(++pat, ++b != b_end);

if(checkBits&NODECHECK) {
printf("place %d.%d=%d\n", p->x-1, p->y, p->oidx);
for(j=1; j<=curWidth; ++j)
printf("%x", b0[j]);
printf("\n");
}

#if 0
if(badSpan[0].drop && dy == min_y && !spanTest(b0, o, x0, dy)) {
// oops, this was a mistake
pat -= o->w; o->pattern;
b -= o->w;
do *b &= ~(*pat<<dy); while(++pat, ++b != b_end);
goto next;
}
#endif

/* downgrade breakLine */
j = o->breakLine + p->y;
if(j < breakLine) breakLine = j;

if(min_y_count) goto advance;
// find lowest level
mask = 0xffff;
for(i=curWidth; i; --i)
mask &= b0[i];
min_y = lowEmpty[mask];
min_y_bit = (1 << min_y);
min_y_count = 0;
for(i=curWidth; i; --i)
if(!(b0[i]&min_y_bit)) ++min_y_count;
goto advance;

backup:
--lev, --p;
if(lev < 0) {
ThreadLock;
// If this node has no descendants, there's no strong reason to keep it
// around in cache. This hardly ever happens.
if(!children && this_idx) {
readNode(this_idx, &compnode);
compnode.dead = true;
writeNode(this_idx, &compnode);
markOldNode(this_idx, compnode.hash);
}
--nodesPending;
ThreadUnlock;
if(showdots) printf(".");
return;
}

/* unplace piece */
unplace:
o = p->o;
pat = o->pattern;
b = b0 + p->x - o->x;
b_end = b + o->w;
dy = p->y - o->y;
do *b &= ~(*pat<<dy); while(++pat, ++b != b_end);

if(reset >= 0) {
if(p->y - o->y > reset) goto backup;
reset = -1;
}

breakLine = p->breakLine;
min_y = p->min_y;
min_y_bit = (1 << min_y);
min_y_count = p->myc;
goto next;

complete:
children = true;
ambinclude = ambnode = false;
reset = breakLine - (setMinDimension-1)/2;

recomplete:
/* build a new instance of the board, with only those pieces
 * that would be included on the lower side of the breakLine. */
if(r_shorts)
for(j=0; j<curWidth; ++j)
b1[j+1] = base_s[j];
else
for(j=0; j<curWidth; ++j)
b1[j+1] = base_b[j];
b1[0] = b1[curWidth1] = 0xffff;

for(q=placeTry; q<p; ++q) {
o = q->o;
dy = o->breakLine + q->y - breakLine;
if(dy > 0) continue;
if(dy == 0 && o->ambig && !ambinclude) {
ambnode = true;
continue;
}

/* place piece */
pat = o->pattern;
b = b1 + q->x - o->x;
b_end = b + o->w;
dy = q->y - o->y;
do *b |= (*pat<<dy); while(++pat, ++b != b_end);
} /* loop over placed pieces */

/* compute depth and shift the patttern back down to the floor */
mask = 0xffff;
for(j=1; j<=curWidth; ++j)
mask &= b1[j];
i = lowEmpty[mask];
newnode.depth = curDepth + i;
if(i) {
if(i > 8*(1+r_shorts)) bailout("depth difference %d is too high", i);
for(j=1; j<=curWidth; ++j)
b1[j] >>= i;
} else if(ambnode) {
/* did we make the same node again? */
if(r_shorts)
for(j=1; j<=curWidth; ++j)
if(b1[j] != base_s[j]) break;
else
for(j=1; j<=curWidth; ++j)
if(b1[j] != base_b[j]) break;
if(j == curWidth1) goto ambtest;
}

mask = 0;
for(j=1; j<=curWidth; ++j) {
mask |= b1[j];
if(r_shorts)
newnode.pattern.s[j-1] = b1[j];
else
newnode.pattern.b[j-1] = b1[j];
}
for(i=0; mask; ++i, mask>>=1)  ;
newnode.gap = i;
if(i > 8*(1+r_shorts)) bailout("gap %d is too high", i);
if(i == 0) bailout("zero gap at depth %d", newnode.depth);
newnode.dead = false;
newnode.parent = this_idx;

if(checkBits&NODECHECK) {
printf("%d:%d:", newnode.depth, newnode.gap);
if(r_shorts)
showPattern(newnode.pattern.s);
else
showSmallPattern(newnode.pattern.b);
printf(" from ");
showPattern(b0+1);
printf("\n");
}

if(!stopstore(newnode)) {
bool rc;
ThreadLock;
rc = findNode(&newnode, true, &looknode);
ThreadUnlock;
if(rc) goto ambtest;
} else noincrease = true;

if(newnode.depth + reachup >= leastRow ||
checkBits&LOOKALLCHECK) {
/* by inserting first, this complement check now tests whether
 * the node matches itself. */
mask = (1<<newnode.gap) - 1;
if(r_shorts) {
for(j=0; j<curWidth; ++j)
compnode.pattern.s[j] = (reverseShort((newnode.pattern.s[j]^mask)) >> (16-newnode.gap));
} else {
for(j=0; j<curWidth; ++j)
compnode.pattern.b[j] = (reverseByte((uchar)(newnode.pattern.b[j]^mask)) >> (8-newnode.gap));
}
if(checkBits&NODECHECK) {
printf("complement:");
if(r_shorts)
showPattern(compnode.pattern.s);
else
showSmallPattern(compnode.pattern.b);
printf("\n");
}
ThreadLock;
if(findNode(&compnode, false, &looknode))
matchFound(&newnode, &looknode);
ThreadUnlock;
} else noincrease = true;

ambtest:
if(ambnode && !ambinclude) { ambnode = false; ambinclude = true; goto recomplete; }
goto backup;
#undef b0
} /* expandNode */

// One of these workers per worker thread
static void *expandWorker(void *notused)
{
long n; /* index of node being expanded */
struct NODE buf; /* node buffer */
while(n = getNode(&buf)) {
expandNode(n, buf.pattern.b);
// Wait a minute - we might have found a better solution.
// Can we stop searching?
if(stopsearch) break;
if(bestRow < curWidth && !(checkBits&LOOKALLCHECK)) break;
}
return NULL;
}

// Expand all the nodes in the pending list at the current depth.
static void expandNodes(void)
{
static pthread_t workerThread[NUMTHREADS];
static bool threadActive[NUMTHREADS];
int i;

workEnd = workStep = 0;
nodeStep = mon_idx;
if(restartParent && restartParent >= nodeStep) nodeStep = restartParent + 1;

if(!numThreads) {
expandWorker(NULL);
return; // that was easy
}

create:
for(i=0; i<numThreads; ++i)
if(!threadActive[i]) {
if(pthread_create(workerThread+i, NULL, expandWorker, NULL))
bailout("cannot creat thread, errno %d", errno);
threadActive[i] = 1;
if(checkBits & SHOWTHREAD) printf(" c%d", i);
}

/*********************************************************************
The first 7 threads could find no more nodes to process, and quit.
The last thread processes the last node and creates lots more nodes;
now the work continues with just one worker thread.
I don't know if this would ever happen, but I'm trying to guard against it.
After each join, if there is more work to do, and no reason to stop,
then I go back and create the threads again.
So I have to duplicate here any reason that these threads would stop,
so I don't keep creating them in an infinite loop.
*********************************************************************/

for(i=0; i<numThreads; ++i) {
if(!threadActive[i]) continue;
pthread_join(workerThread[i], NULL);
if(checkBits & SHOWTHREAD) printf(" j%d", i);
threadActive[i] = 0;
if(inTerm) continue;
if(stopsearch) continue;
if(bestRow < curWidth && !(checkBits&LOOKALLCHECK)) continue;
if(nodeStep >= nodesDisk && workStep >= workEnd) continue;
goto create;
}
} /* expandNodes */

/*********************************************************************
When a node is generated, we want to  determine, quickly,
whether we have seen it before.
Or whether we have seen its complement.
A linear search is hardly appropriate.
We use a hash lookup.
This function computes the hash value for a pattern.
By selecting a cannonical direction to scan the pattern,
the hash value is the same for a pattern and its reflection.
Thus computeHash() may reverse your pattern - and we want that!
As always, the hash has about 10% slop.
If we allow 40 meganodes, we might have an array of 45 million hash indexes.
The hash value leads to a long.
The bottom 31 bits determine the corresponding node on disk.
Thus we can store 2^31 nodes on disk. That is a hard limit on nodes.
The high bit, or sign bit, is an old indicator, as in markOldNode().
The node is at a lower depth, and will not participate in a solution at curDepth.
If a new node comes in at the same hash value, we can displace the old node.
This will not prevent us from finding a solution, but it is forgetting a node.
If that same node comes along again we'll store it and expand it,
and maybe get in an infinite loop if not bounded by bestOrder.
nodesCache counts the active nodes in cache, not the old nodes.
So when we mark a node as old we decrement nodesCache.
*********************************************************************/

static long *hashIdx; // array of hashed indexes
static bool reversibleHash = true;

static long computeHashBytes(uchar *p)
{
int j, k, direction;
ulong hash = 0;
shapebits v;
uchar swap;
ulong prime = 2147483629;
ulong m_factor = (ulong)0x80000000 - prime;

direction = 1;
if(reversibleHash) {
k = curWidth-1;
for(j=0; j+j<curWidth; ++j, --k) {
if(p[j] == p[k]) continue;
if(p[j] < p[k]) direction = -1;
break;
}

if(direction < 0) {
k = curWidth-1;
for(j=0; j+j<curWidth; ++j, --k)
swap = p[j], p[j] = p[k], p[k] = swap;
}
}

for(j=0; j<curWidth; ++j) {
v = p[j];
// hash = (hash * 65536 + v) mod prime
hash = ((hash&0x7fff)<<16) + ((hash>>15)*m_factor);
hash += v;
if(hash >= prime) hash -= prime;
}

if(hash >= prime) bailout("hash value too large", 0);

// 0 hash value is not allowed
if(!hash) hash = 1;
return (long)hash;
}

static long computeHashShorts(ushort *p)
{
int j, k, direction;
ulong hash = 0;
shapebits v;
ushort swap;
ulong prime = 2147483629;
ulong m_factor = (ulong)0x80000000 - prime;

direction = 1;
if(reversibleHash) {
k = curWidth-1;
for(j=0; j+j<curWidth; ++j, --k) {
if(p[j] == p[k]) continue;
if(p[j] < p[k]) direction = -1;
break;
}

if(direction < 0) {
k = curWidth-1;
for(j=0; j+j<curWidth; ++j, --k)
swap = p[j], p[j] = p[k], p[k] = swap;
}
}

for(j=0; j<curWidth; ++j) {
v = p[j];
// hash = (hash * 65536 + v) mod prime
hash = ((hash&0x7fff)<<16) + ((hash>>15)*m_factor);
hash += v;
if(hash >= prime) hash -= prime;
}

if(hash >= prime) bailout("hash value too large", 0);

// 0 hash value is not allowed
if(!hash) hash = 1;
return (long)hash;
}


static void recache(void);

static void initFiles(void)
{
int flags;
int i, j;
static char *xptr;

if(!xptr) xptr = strchr(filename, 'x');

if(workList) free(workList);
workAlloc = 60;
workList = emalloc(4*workAlloc);
workEnd = 0;

nodeSize = sizeof(struct NODE) - BOARDWIDTH*2 + curWidth;
if(r_shorts) nodeSize += curWidth;
nodeSize = (nodeSize + 3) & ~3;
nodesInFile = 0x7fff0000 / nodeSize;
megaNodes = startMega;
maxNodes = megaNodes * 0x100000;
slopNodes = maxNodes / 8 * 9;
reachup = 0;

if(restart) { /* resume program */
long l;
struct NODE buf;
int cutoff = restart + forgetgap;

nodesDisk = 0;
for(i=0; i<60; ++i) {
flags = O_RDWR|O_BINARY;
*xptr = 'A' + i;
fd[i] = open(filename, flags, 0666);
if(fd[i] < 0) bailout("cannot reopen data file, errno %d", errno);
l = lseek(fd[i], 0, SEEK_END);
if(l%nodeSize) bailout("data file has bad length %ld", l);
nodesDisk += l/nodeSize;
} /* loop over files */

readNode(nodesDisk-1, &buf);
restartParent = buf.parent;
if(!restartParent) bailout("restartParent is 0", 0);
readNode(restartParent, &buf);
if(buf.depth != restart)
bailout("last depth was %d", buf.depth);

mon_idx = 0;
nodesPending = 0;
for(j=1; j<nodesDisk; ++j) {
readNode(j, &buf);
if(buf.dead) continue;
if(buf.depth == restart && j > restartParent) ++nodesPending;
if(buf.depth > restart) ++nodesPending;
if(buf.depth > cutoff && !mon_idx) mon_idx = j;
if(buf.depth + buf.gap > reachup) reachup = buf.depth + buf.gap;
}

printf("Restart with %d nodes, %d pending\n", nodesDisk, nodesPending);

curDepth = restart;
recache();
return;
} /* resume program */

if(hashIdx && megaNodes > startMega) {
free(hashIdx);
hashIdx = 0;
}

if(!hashIdx) hashIdx = emalloc(slopNodes * sizeof(long));
memset(hashIdx, 0, slopNodes*sizeof(long));
nodesCache = 0;
hwm = 0;

nodesDisk = 1; /* the initial node of all zeros is at location 0 */
mon_idx = 1;
nodesPending = 1;
curDepth = 0;

for(i=0; i<60; ++i) {
if(fd[i] > 0) close(fd[i]);
flags = O_CREAT|O_TRUNC|O_RDWR|O_BINARY;
*xptr = 'A' + i;
fd[i] = open(filename, flags, 0666);
if(fd[i] < 0) bailout("cannot create data file, errno %d", errno);
} /* loop over files */
} /* initFiles */

static void showPoly(const shapebits *p)
{
int i;
shapebits x;

for(i=0; i<REPDIAMETER; ++i) {
x = p[i];
if(!x) break;
printf("%02x", x>>8);
x &= 0xff;
if(x == 0x80) printf("+");
else if(x) printf("<%02x>", x);
}
} /* showPoly */



/*********************************************************************
Read and write nodes by index.
Look up nodes by hash.
Insert new nodes if they're not already present.
*********************************************************************/

// Recache all the active nodes - as part of resumption.
static void recache(void)
{
static struct NODE rebuf, redest; /* for recaching */
int cutoff = curDepth + forgetgap;
int j;
long n, hash, idx;
long *hb;

hashIdx = emalloc(slopNodes * sizeof(long));
memset(hashIdx, 0, slopNodes*sizeof(long));
nodesCache = 0;
hwm = 0;

for(j=mon_idx; j<nodesDisk; ++j) {
if(j % 100000 == 0) printf(".");
readNode(j, &rebuf);
if(rebuf.dead) continue;
if(rebuf.depth <= cutoff) continue;

hash = rebuf.hash;
n = hash % slopNodes;

hb = hashIdx + n;
while(true) {
idx = *hb;
if(!idx) break;
idx &= 0x7fffffff;
readNode(idx, &redest);
if(redest.hash != hash) goto nextnode;
if(memcmp(redest.pattern.b, rebuf.pattern.b, curNodeWidth)) goto nextnode;
if(rebuf.depth < redest.depth) *hb = j;
goto nextDisk;
nextnode:
++n, ++hb;
if(n == slopNodes) n = 0, hb = hashIdx;
}

*hb = j;

if(++nodesCache >= maxNodes)
bailout("cannot recache at level %d", megaNodes);

nextDisk: ;
} /* loop recaching nodes on disk */
} /* recache */

/* Look for a node by hash value. */
/* Return true if the node was found. */
static bool findNode( struct NODE *look, bool insert, struct NODE *dest)
{
long *hb;
long n, hash, idx;
long empty = -1;
int j;

if(r_shorts)
hash = computeHashShorts(look->pattern.s);
else
hash = computeHashBytes(look->pattern.b);
n = hash % slopNodes;

hb = hashIdx + n;
while(true) {
idx = *hb;
if(!idx) break;
if(idx < 0) {
if(empty < 0) empty = n;
if(!insert) goto nextnode;
idx &= 0x7fffffff;
}

readNode(idx, dest);
if(dest->hash != hash) goto nextnode;
if(memcmp(dest->pattern.b, look->pattern.b, curNodeWidth)) goto nextnode;
if(insert && look->depth < dest->depth) {
dest->depth = look->depth;
dest->parent = look->parent;
writeNode(idx, dest);
if(look->depth == curDepth && idx < look->parent)
appendWorkList(idx);
} /* downgrading the depth */
return true;
nextnode:
++n, ++hb;
if(n == slopNodes) n = 0, hb = hashIdx;
}

if(!insert) return false;
j = look->depth + look->gap;
if(j > reachup) reachup = j;

if(checkBits&NODECHECK) printf("insert %ld\n", n);

if(nodesDisk >= 2140000000) bailout("too many nodes, limit 2 billion", 0);
if(nodesDisk/60 >= nodesInFile)
bailout("too many nodes for 60 data files on disk", 0);
look->hash = hash;
writeNode(nodesDisk, look);

if(empty >= 0) n = empty;
hb = hashIdx + n;
*hb = nodesDisk;
++nodesDisk;
++nodesPending;
if(++nodesCache >= maxNodes && !inTerm) {
printf("\nCache overflow; you will have to restart with a higher cache.\n%d@%d^%d\n",
curWidth, curDepth, megaNodes);
inTerm = 1;
}

j = nodesCache / (maxNodes/10);
if(j == 10) j = 9;
if(j > hwm) { hwm = j; printf(" %%%d0", j); }

return false;
} /* findNode */

static void markOldNode(long jdx, long hash)
{
long *hb;
long n, idx;

n = hash % slopNodes;
hb = hashIdx + n;
while(true) {
idx = *hb;
if(!idx) break;
if((idx&0x7fffffff) == jdx) {
*hb |= 0x80000000;
--nodesCache;
return; /* found it */
}
++n, ++hb;
if(n == slopNodes) n = 0, hb = hashIdx;
}

/* Apparently it was already removed from the cache. */
} /* markOldNode */

static void markOldNodes(void)
{
long idx;
static struct NODE buf;
int cutoff = curDepth + forgetgap;
bool firstBigger = true;

if(checkBits & ALLCACHE) return;
if(cutoff < 0) return;

for(idx=mon_idx; idx<nodesDisk; ++idx) {
readNode(idx, &buf);
if(buf.dead) continue;
if(buf.depth > cutoff && firstBigger) { firstBigger = false; mon_idx = idx; }
if(buf.depth == cutoff) markOldNode(idx, buf.hash);
} /* loop scanning all nodes on disk */
} /* markOldNodes */


static void expandFirstNode(void)
{
static struct NODE floor;
expandNode(0, floor.pattern.b);
} /* expandFirstNode */


/*********************************************************************
We found a match.
Two nodes complement each other perfectly.
Follow both nodes backwards to the floor to build both halves
of the tiled rectangle.
Then put the two halves together.
Dump the solution to a file and return,
whence we can look for a better one.
*********************************************************************/

static char *leftBoard, *rightBoard;
static int better_h, better_area; /* better than our last solution */
static struct PLACE placeSolve[BOARDWIDTH];
static int pno; /* piece number */

/* place pieces between two nodes */
static int betweenNodes(const struct NODE *nb, const struct NODE *nt)
{
int lev = -1; /* placement level */
struct PLACE *p = placeSolve - 1;
const struct ORIENT *o;
shapebits b[BOARDWIDTH];
int i, j, k;
int best_x, best_y, best_val;
shapebits mask;
ulong orients[3]; /* bitmap of viable orientations */
int diff = nt->depth - nb->depth;

if(checkBits&SOLVECHECK) {
printf("between %d and %d:", nb->depth, nt->depth);
if(r_shorts) {
showPattern(nb->pattern.s);
printf(":");
showPattern(nt->pattern.s);
} else {
showSmallPattern(nb->pattern.b);
printf(":");
showSmallPattern(nt->pattern.b);
}
printf("\n");
}

b[0] = b[curWidth1] = 0xffff;
if(r_shorts) {
for(i=0; i<curWidth; ++i) {
mask = nt->pattern.s[i];
mask ^= 0xffff;
mask <<= diff;
if(mask & nb->pattern.s[i]) return 0;
mask |= nb->pattern.s[i];
b[i+1] = mask;
}
} else {
for(i=0; i<curWidth; ++i) {
mask = nt->pattern.b[i];
mask ^= 0xffff;
mask <<= diff;
if(mask & nb->pattern.b[i]) return 0;
mask |= nb->pattern.b[i];
b[i+1] = mask;
}
}

if(checkBits&SOLVECHECK) {
showPattern(b+1);
printf("\n");
}

advance:
if(++lev >= BOARDWIDTH)
bailout("placement stack overflow", 0);
++p;

/* find location to place the piece */
best_x = 0;
best_val = O_MAX + 1;
for(i=1; i<=curWidth; ++i) {
j = lowEmpty[b[i]];
if(j == REPDIAMETER) continue;
mask = 1<<j;
if(!(b[i-1]&mask)) continue;
p->x = i, p->y = j;

/* count orientations */
j = 0;
clearOrientBits(orients);
o = o_leftlist;
for(p->oidx=0; p->oidx<o_max; ++p->oidx, ++o) {
if(o->y > p->y) continue;
if(p->x <= o->x) continue;
if(p->x - o->x + o->w > curWidth1) continue;
for(k=0; k<o->w; ++k)
if(b[p->x-o->x+k] & (o->pattern[k]<<(p->y-o->y))) break;
if(k < o->w) continue;
if(++j >= best_val) goto nextColumn;
setOrientBit(orients, p->oidx);
} /* loop over orientations */
if(j == best_val) continue;

if(!j) goto backup;
best_x = p->x, best_y = p->y;
best_val = j;
copyOrientBits(p->orients, orients);
if(j == 1) break;
nextColumn: ;
}

if(!best_x) return lev;

p->x = best_x;
p->y = best_y;
p->oidx = -1;

next:
if(++p->oidx >= o_max) goto backup;
if(!testOrientBit(p->orients, p->oidx)) goto next;
p->o = o = o_leftlist + p->oidx;
/* place piece */
for(i=0; i<o->w; ++i)
b[p->x-o->x+i] |= (o->pattern[i]<<(p->y-o->y));
goto advance;

backup:
--lev, --p;
if(lev < 0) return 0;
o = p->o;
/* unplace piece */
for(i=0; i<o->w; ++i)
b[p->x-o->x+i] &= ~ (o->pattern[i]<<(p->y-o->y));
goto next;
} /* betweenNodes */

/* do the two half boards overlap? */
static bool boardsOverlap(void)
{
int i;
for(i=0; i<better_area; ++i)
if(leftBoard[i] != '?' && rightBoard[better_area-1-i] != '?')
return true;
return false;
} /* boardsOverlap */

static void flipBoard(char *b)
{
int i, j, k;
char swap;
for(i=0; i<better_h; ++i) {
k = curWidth-1;
for(j=0; j+j<curWidth; ++j, --k)
swap = b[curWidth*i+j], b[curWidth*i+j] = b[curWidth*i+k], b[curWidth*i+k] = swap;
}
} /* flipBoard */

static void mergeBoards(void)
{
int i;
char c;
for(i=0; i<better_area; ++i) {
c = leftBoard[i];
if(c != '?') continue;
c = rightBoard[better_area-1-i];
if(c == '?') bailout("double ? at %d", i);
leftBoard[i] = c;
}
} /* mergeBoards */

static void downToFloor(char *board, const struct NODE *top)
{
struct NODE n1, n2;
struct NODE floor;
long parent;
int added;
struct PLACE *p;
int i, j, k;

if(checkBits&SOLVECHECK) {
printf("top%d:", top->depth);
if(r_shorts)
showPattern(top->pattern.s);
else
showSmallPattern(top->pattern.b);
printf("\n");
}

n2 = *top;
memset(&floor, 0, sizeof(floor));

do {
parent = n2.parent;
if(parent) {
readNode(parent, &n1);
} else {
n1 = floor;
}
added = betweenNodes(&n1, &n2);
if(!added) { /* try flipping the pattern */
k = curWidth-1;
if(r_shorts) {
ushort swap;
for(j=0; j+j<curWidth; ++j, --k)
swap = n1.pattern.s[j], n1.pattern.s[j] = n1.pattern.s[k], n1.pattern.s[k] = swap;
} else {
uchar swap;
for(j=0; j+j<curWidth; ++j, --k)
swap = n1.pattern.b[j], n1.pattern.b[j] = n1.pattern.b[k], n1.pattern.b[k] = swap;
}
added = betweenNodes(&n1, &n2);
}
if(!added) {
printf("\nunfillable %d.%d:\n", n1.depth, n2.depth);
if(r_shorts)
showPattern(n1.pattern.s);
else
showSmallPattern(n1.pattern.b);
printf("\n");
if(r_shorts)
showPattern(n2.pattern.s);
else
showSmallPattern(n2.pattern.b);
printf("\n");
bailout("cannot fill the space between two successive nodes.", 0);
}

for(p=placeSolve; added; --added, ++p) {
int x = p->x - 1;
int y = p->y;
const struct ORIENT *o = p->o;
shapebits mask;
bool used[26];

memset(used, 0, sizeof(used));
for(i=0; i<o->w; ++i) {
mask = o->pattern[i];
k = x - o->x + i;
for(j=n1.depth+y-o->y; mask; ++j, mask>>=1) {
if(!(mask&1)) continue;
if(k && board[j*curWidth+k-1] != '?')
used[board[j*curWidth+k-1]-'a'] = true;
if(k < curWidth-1 && board[j*curWidth+k+1] != '?')
used[board[j*curWidth+k+1]-'a'] = true;
if(j && board[(j-1)*curWidth+k] != '?')
used[board[(j-1)*curWidth+k]-'a'] = true;
if(board[(j+1)*curWidth+k] != '?')
used[board[(j+1)*curWidth+k]-'a'] = true;
}
} /* loop over columns in the piece */

k = pno + 1;
do {
if(k == 26) k = 0;
if(!used[k]) break;
} while(++k != pno);
if(k == pno) bailout("surrounded by 25 colors", 0);
pno = k;

for(i=0; i<o->w; ++i) {
mask = o->pattern[i];
k = x - o->x + i;
for(j=n1.depth+y-o->y; mask; ++j, mask>>=1) {
if(!(mask&1)) continue;
board[j*curWidth + k] = pno + 'a';
}
} /* loop over columns in the piece */
} /* loop over pieces between the nodes */

n2 = n1;
} while(parent); /* loop down through the depths */
} /* downToFloor */

static void matchFound(const struct NODE *left, const struct NODE *right)
{
int newOrder;
char solname[120];
int i, fd;

better_h = left->depth + right->depth + left->gap;
better_area = better_h*curWidth;
if(better_h%dimFactor || better_area % (nsq*ordFactor))
bailout("impossible dimensions, height %d", better_h);
newOrder = better_area/nsq;
if(newOrder > bestOrder) return;

printf(" *%d[%dx%d", newOrder, curWidth, better_h);

leftBoard = emalloc(better_area);
rightBoard = emalloc(better_area);
memset(leftBoard, '?', better_area);
memset(rightBoard, '?', better_area);

pno = 0;
downToFloor(leftBoard, left);
/* Make it a bit less likely that letters will collide when we put
 * the two half boards together. */
pno = 13;
downToFloor(rightBoard, right);
printf("]");

if(boardsOverlap()) {
flipBoard(rightBoard);
if(boardsOverlap())
bailout("cannot put the two halves of the solution together", 0);
}

mergeBoards();

sprintf(solname, "dotile/%s/sol%dx%d",
piecename, curWidth, better_h);
fd = open(solname, O_CREAT|O_TRUNC|O_WRONLY, 0666);
if(fd < 0) bailout("cannot create solution file %s", (int)solname);
for(i=0; i<better_h; ++i) {
ewrite(fd, leftBoard+i*curWidth, curWidth);
ewrite(fd, "\n", 1);
}
close(fd);

free(leftBoard);
free(rightBoard);

bestOrder = newOrder - 1;
setBestRow();
} /* matchFound */


/*********************************************************************
As a sanity check, see if the piece tiles a good chunk of the first quadrant.
This is necessary, but not sufficient.
There are plenty of pieces, such as ff80,
that tile the entire quadrant, but not a rectangle.
This is not efficient - just simple code.
*********************************************************************/

#define QBWIDTH 90
#define DIAGLIMIT QBWIDTH - REPDIAMETER

static bool qboard[QBWIDTH*QBWIDTH]; /* the quadrant board */
static short qori[8][NSQ]; /* the quadrant orientations */
static int diagMax;

/* Convert our bitmap orientations into arrays of ofsets. */
/* Discard most of them in the process, leaving only the basic 8. */
static void quadConvert(void)
{
struct ORIENT *o, *q;
int o_idx, n_idx;
int i, j, k;
shapebits mask;

n_idx = 1;
o = o_leftlist;
for(o_idx=0; o_idx<o_max; ++o_idx, ++o) {
if(!o_idx) continue; /* first one's free */
q = o_leftlist + n_idx - 1;
if(q->w == o->w && q->h == o->h &&
!memcmp(q->pattern, o->pattern, o->w*sizeof(shapebits))) {
if(o->x + o->y < q->x + q->y ||
o->x + o->y == q->x + q->y && o->y < q->y)
*q = *o; /* structure copy */
continue;
}
++n_idx;
++q;
if(q != o) *q = *o; /* structure copy */
}
o_max = n_idx;

o = o_leftlist;
for(o_idx=0; o_idx<o_max; ++o_idx, ++o) {
k = 0;

for(i=0; i<o->w; ++i) {
mask = o->pattern[i];
for(j=0; mask; ++j, mask>>=1) {
if(!(mask&1)) continue;
if(i == o->x && j == o->y) continue;
qori[o_idx][k++] = (j-o->y)*QBWIDTH + i-o->x;
}
}

qori[o_idx][k++] = 0;
if(k != nsq) bailout("quad convert found %d squares in a piece", k);
} /* loop over orientations */
} /* quadConvert */

static bool testQori(int loc, int o)
{
const short *s = qori[o];
for(; *s; ++s)
if(qboard[loc + *s]) return false;
return true;
} /* testQori */

static void placeQori(int loc, int o)
{
const short *s = qori[o];
for(; *s; ++s)
qboard[loc + *s] = true;
qboard[loc] = true;
} /* placeQori */

static void unplaceQori(int loc, int o)
{
const short *s = qori[o];
for(; *s; ++s)
qboard[loc + *s] = false;
qboard[loc] = false;
} /* unplaceQori */

static void quadAction(int x, int y)
{
int loc;
int o;
struct ORIENT *op;

while(true) {
loc = QBWIDTH*y+x;
if(!qboard[loc]) break;
--x, ++y;
if(x) continue;
++y;
x = y;
y = 0;
if(x == DIAGLIMIT) { puts("ok"); exit(0); }
if(x > diagMax) diagMax = x;
--x, ++y;
}

op = o_leftlist;
for(o=0; o<o_max; ++o, ++op) {
if(x <= op->x || y <= op->y) continue;
if(!testQori(loc, o)) continue;
if(checkBits&SOLVECHECK) printf("%d,%d=%d\n", x, y, op->ono);
placeQori(loc, o);
quadAction(x, y);
unplaceQori(loc, o);
if(checkBits&SOLVECHECK) printf("%d,%d=x\n", x, y);
} /* loop over orientations */
} /* quadAction */

static void quadTest(void)
{
int i;

quadConvert();

for(i=0; i<QBWIDTH; ++i) qboard[i] = qboard[QBWIDTH*i] = true;

quadAction(1, 1);
printf("failed at diagonal %d\n", diagMax);
exit(1);
} /* quadTest */


/*********************************************************************
Produce successive open ended nodes - open at the right -
climbing up the left wall.
If we can't produce a flat ceiling, we obviously can't tile a rectangle.
This is not efficient - it assumes you're not going to generate very many nodes before success or failure.
The width of the nodes is assumed small - around 8.
*********************************************************************/

static uchar *oenArray; /* array of open ended nodes */
static ushort *oenDepth;

/* expand an open ended node */
static bool expandOen(const uchar *base)
{
int lev; /* placement level */
struct PLACE *p;
const struct PLACE *q;
const struct ORIENT *o;
int width, newDepth;
const shapebits *pat;
shapebits mask, dymask;
int i, j, k;
int dy;
int min_y;
shapebits min_y_bit;
bool reset = false;
long n, idx, hash, *hb;
shapebits b0[BOARDWIDTH];
shapebits b1[BOARDWIDTH];
uchar b2[BOARDWIDTH];
struct PLACE placeTry[BOARDWIDTH];

memset(b0, 0, sizeof(b0));
for(j=0; j<curWidth; ++j)
b0[j] = base[j];
min_y = 0;
min_y_bit = 1;

p = placeTry - 1, lev = -1;

advance:
if(++lev >= BOARDWIDTH)
bailout("placement stack overflow", 0);
++p;

/* find location to place the piece */
relook:
for(j=0; j<curWidth; ++j)
if(!(b0[j]&min_y_bit)) break;
if(j >= curWidth) {
++min_y, min_y_bit <<= 1;
if(min_y < lookahead) goto relook;
goto complete;
}

p->x = j;
p->min_y = min_y;
p->oidx = -1;

next:
if(++p->oidx >= o_max) goto backup;
p->o = o = o_leftlist + p->oidx;
dy = min_y-o->y;
if(dy < 0) {
if(dy+curDepth < 0) goto next;
dymask = (1<<-dy) - 1;
}
k = j - o->x;
if(k < 0) goto next;
width = o->w;
if(k+width > curWidth) width = curWidth - k;
pat = o->pattern;
for(i=0; i<o->w; ++i) {
if(dy >= 0) {
if(b0[k+i]&(pat[i]<<dy)) goto next;
continue;
}
/* shifting the pattern down */
if(i < width && pat[i]&dymask) goto next;
if(b0[k+i]&(pat[i]>>-dy)) goto next;
}

for(i=0; i<o->w; ++i) {
if(dy >= 0)
b0[k+i] |= (pat[i]<<dy);
else
b0[k+i] |= (pat[i]>>-dy);
}
goto advance;

backup:
--lev, --p;
if(lev < 0) return false;

/* unplace piece */
min_y = p->min_y;
min_y_bit = 1<<min_y;
j = p->x;
o = p->o;
dy = min_y-o->y;
k = j - o->x;
pat = o->pattern;
for(i=0; i<o->w; ++i) {
if(dy >= 0)
b0[k+i] &= ~(pat[i]<<dy);
else
b0[k+i] &= ~(pat[i]>>-dy);
}
if(reset && min_y) goto backup;
reset = false;
goto next;

complete:
reset = true;
/* compute depth and shift the patttern back down to the floor */
memset(b1, 0, curWidth*sizeof(shapebits));
for(q=placeTry; q<p; ++q) {
if(q->min_y) continue;
o = q->o;
j = q->x;
k = j - o->x;
width = o->w;
if(k+width > curWidth) width = curWidth - k;
pat = o->pattern;
for(i=0; i<width; ++i)
b1[k+i] |= (pat[i]>>o->y);
}

mask = 0xffff;
for(j=0; j<curWidth; ++j)
mask &= (b1[j] |= base[j]);
i = lowEmpty[mask];
newDepth = curDepth + i;
for(j=0; j<curWidth; ++j)
b1[j] >>= i;

mask = 0;
for(j=0; j<curWidth; ++j)
mask |= b2[j] = b1[j];
if(!mask) {
printf(" :%d ok\n", nodesCache);
return true;
}

/* Have we seen this node before? */
hash = computeHashBytes(b2);
n = hash % slopNodes;
hb = hashIdx + n;
while(true) {
idx = *hb;
if(!idx) break;
if(!memcmp((uchar*)idx, b2, curWidth)) goto backup;
++n, ++hb;
if(n == slopNodes) n = 0, hb = hashIdx;
}

if(nodesCache >= maxNodes)
bailout("too many nodes", 0);
*hb = (long)(oenArray + curWidth*nodesCache);
memcpy(oenArray + nodesCache*curWidth, b2, curWidth);
oenDepth[nodesCache] = newDepth;
++nodesCache;

if(checkBits&NODECHECK) {
printf("%d=", newDepth);
showSmallPattern(b2);
printf("\n");
}

goto backup;
} /* expandOen */

static void oenTest(void)
{
static uchar base0[BOARDWIDTH];
int i, j;
int lastDepth;

reversibleHash = false;
maxNodes = startMega * 1000000;
slopNodes = maxNodes / 8 * 9;
oenDepth = emalloc(maxNodes*sizeof(ushort));
hashIdx = emalloc(slopNodes*sizeof(long));

for(; curWidth < BOARDWIDTH-setMaxDimension; curWidth += dimFactor) {
curWidth1 = curWidth + 1;
curNodeWidth = curWidth * (1+r_shorts);
printf("?%d", curWidth);
oenArray = emalloc(maxNodes*curWidth);
memset(hashIdx, 0, slopNodes*sizeof(long));
nodesCache = 0;
lastDepth = 0;
curDepth = 0;
if(expandOen(base0)) goto ok;
for(j=0; j<nodesCache; ++j) {
curDepth = oenDepth[j];
if(curDepth > lastDepth) { lastDepth = curDepth; printf(" @%d", curDepth); }
if(expandOen(oenArray+j*curWidth)) goto ok;
}
printf(" :%d failed\n", nodesCache);
exit(1);
ok:
free(oenArray);
}

free(hashIdx);
free(oenDepth);
exit(0);
} /* oenTest */


